<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KAGO</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Yandex Maps API will be used for maps -->
    <style>
        :root {
            /*
             * Refresh the colour palette to evoke the bright, friendly look of
             * modern delivery apps. A warm yellow primary accent and playful
             * pink secondary accent are complemented by soft greys and an
             * off‑white background. Rounded corners and a gentler box shadow
             * complete the updated aesthetic.
             */
            --primary: #0077ff;
            --secondary: #ff0000;
            --success: #4caf50;
            --warning: #ff9800;
            --dark: #00277c;
            --light: #ffffff;
            --white: #ffffff;
            --gray: #868e96;
            --light-gray: #f1f3f5;
            /* Custom pastel colours for different card categories used in the main page layout. */
            --cat-bg: #ffffff00;
            --branch-type-bg: #ffffff00;
            --popular-branch-bg: #ffffff00;
            --all-branch-bg: #ffffff00;
            --border-radius: 18px;
            --box-shadow: 0 0px 0px
            --transition: all 0.3s ease;
        }

        /*
         * Dark mode support
         *
         * The site automatically switches to a dark theme outside the hours of
         * 08:00–19:00. To avoid rewriting every colour definition manually,
         * we invert the entire page using a CSS filter. A double‑invert on
         * images restores their original appearance. This technique keeps the
         * design consistent while giving customers a comfortable viewing
         * experience at night. If you add elements with background images
         * using inline styles, also apply the `.image` class so they are
         * corrected in dark mode.
         */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            /* Use the light background colour instead of pure white to soften the
               overall appearance. */
            background-color: var(--light);
            color: var(--dark);
            min-height: 100vh;
            padding-bottom: 80px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 15px;
        }

        /* Header Styles */
        header {
            /* Semi‑transparent header with blur for a sleek, glassy appearance */
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: var(--box-shadow);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 15px 0;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: nowrap;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
            text-decoration: none;
            display: flex;
            align-items: center;
            flex: 0 0 auto;
        }

        .logo i {
            margin-right: 10px;
        }

        .search-container {
            flex: 1 1 auto;
            margin-left: 20px;
            margin-right: 20px;
            position: relative;
            /* Provide a glassy search bar with a higher opacity for better legibility */
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            min-width: 120px;
        }

        .search-input {
            width: 100%;
            padding: 10px 40px 10px 36px; /* ikonka uchun joy */
            border: 1px solid #ccc;       /* kulrang chiziq */
            border-radius: 20px;          /* yumaloq burchaklar */
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: #0004ff; /* fokusda sariq (brend rangiga moslashtiring) */
        }


        /* --------------------------------------------------
           Restaurant modal grid
           -------------------------------------------------- */
        /* Grid container for restaurants in the modal. Uses CSS Grid to arrange
           restaurant cards responsively. Images are constrained to a square
           aspect ratio and cropped via object-fit. */
        .restaurant-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            padding: 10px;
        }

        .restaurant-grid-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background-color: var(--white);
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .restaurant-grid-item:hover {
            transform: translateY(-4px);
        }

        .restaurant-grid-item img {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }

        .restaurant-grid-item .name {
            width: 100%;
            text-align: center;
            padding: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--dark);
        }

        .search-input::placeholder {
            color: rgba(0, 0, 0, 0.5);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(0, 0, 0, 0.7);
        }

        .header-actions {
            display: flex;
            align-items: center;
        }

        .header-action-btn {
            background: none;
            border: none;
            font-size: 20px;
            color: var(--dark);
            margin-left: 15px;
            cursor: pointer;
            position: relative;
            transition: var(--transition);
        }

        .header-action-btn:hover {
            color: var(--primary);
        }

        /* Splash screen */
        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #c1ff72;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        #splashScreen img {
            width: 150px;
            height: auto;
            animation: splashZoom 2s ease-out forwards;
        }
        @keyframes splashZoom {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* B2B button styles */
        .b2b-btn {
            background-color: #4400ff;
            color: #ffffff;
            padding: 8px 14px;
            border-radius: var(--border-radius);
            text-decoration: none;
            font-weight: 600;
            margin-left: 15px;
            white-space: nowrap;
        }
        .b2b-btn:hover {
            background-color: #00ff22;
            color: #fff;
        }

        /* Make agent chat modal full screen on small devices */
        @media (max-width: 600px) {
            #agentModal .modal-content {
                max-width: none;
                width: 100%;
                height: 100%;
                border-radius: 0;
            }
        }

        .cart-count {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: var(--secondary);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        header {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: var(--box-shadow);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 15px 0;
        }
        /* Hero Slider */
        .hero-slider {
        position: relative;
        width: 100%;
        padding-bottom: 50%;
        overflow: hidden;
        border-radius: var(--border-radius);
        margin: 20px 0;
        perspective: 1000px; /* 3D effekt uchun */
        }

        .hero-slider .slide {
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        backface-visibility: hidden; /* orqa tomonni yashirish */
        transform: rotateY(90deg);
        opacity: 0;
        transition: transform 0.8s ease, opacity 0.8s ease;
        }

        .hero-slider .slide.active {
        transform: rotateY(0deg);
        opacity: 1;
        z-index: 2;
        }

        /* Slayderda rasm bo‘lmasa — joy egallamasin */
        .hero-slider.hidden,
        .hero-slider:empty {
        display: none !important;
        margin: 0 !important;
        padding: 0 !important;
        }

        /* Doʻkonlar modal oynasi uchun stillar */
        .restaurant-list-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid var(--light-gray);
            cursor: pointer;
        }

        .restaurant-list-image {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
        }

        .restaurant-list-name {
            font-weight: 600;
            font-size: 16px;
        }

        .single-restaurant-header {
            display: flex;
            align-items: center;
            padding: 15px;
            background-color: var(--light-gray);
            margin-bottom: 15px;
        }

        .single-restaurant-back {
            margin-right: 15px;
            font-size: 20px;
            cursor: pointer;
        }
        /* Restaurants Section */
        .section-title {
            font-size: 20px;
            font-weight: 600;
            margin: 25px 0 15px;
            color: var(--dark);
            display: flex;
            align-items: center;
        }

        .section-title i {
            margin-right: 10px;
            color: var(--primary);
        }

        .restaurants-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .restaurant-card {
            background-color: var(--white);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
        }

        .restaurant-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgb(255, 255, 255);
        }

        .restaurant-name {
            padding: 15px;
            /* Make restaurant titles larger, bolder and use a serif font to evoke an appetising feel */
            font-size: 20px;
            font-weight: 700;
            font-family: Georgia, 'Times New Roman', serif;
            color: var(--dark);
            transition: color var(--transition);
        }
        .restaurant-name:hover {
            color: var(--primary);
        }

        .dishes-container {
            /* By default use a grid layout. Individual restaurant lists will override this
               with the .restaurant-dishes class to create a horizontal slider. */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            padding: 0 15px 15px;
        }

        .dish-card {
            background-color: var(--white);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: var(--transition);
            cursor: pointer;
            position: relative;
        }

        .dish-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .dish-favorite {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(255, 255, 255, 0.8);
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary);
            z-index: 2;
            cursor: pointer;
        }

        .dish-favorite.active {
            color: var(--secondary);
        }

        .dish-image {
            width: 100%;
            height: 0;
            padding-bottom: 133%; /* 3:4 aspect ratio */
            background-size: cover;
            background-position: center;
        }

        .dish-info {
            padding: 10px;
        }

        .dish-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dish-price {
            font-size: 14px;
            font-weight: 600;
            color: var(--success);
        }

        /* Filial turlari grid */
        .branch-types {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); /* kattaroq */
            gap: 15px;
            margin-bottom: 20px;
        }

        .branch-type-item {
            background-color: var(--branch-type-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            text-align: center;
        }

        .branch-type-item img {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }

        .branch-type-item .name {
            padding: 8px;
            font-size: 15px; /* filial turlari uchun kattaroq yozuv */
            font-weight: 600;
        }

        /* Taom kategoriyalari: horizontally scrollable list that does not shrink. Items keep a fixed width
           and can be scrolled when there are more than five. On smaller screens the images and text scale down
           automatically. */
        .food-categories {
            display: flex;
            overflow-x: auto;
            gap: 8px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            -webkit-overflow-scrolling: touch;
        }

        .food-category-item {
            flex: 0 0 auto;
            width: 120px;
            background-color: var(--cat-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            text-align: center;
        }

        .food-category-item img {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }

        .food-category-item .name {
            padding: 5px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Stores row (Do'konlar) similar to categories: horizontally scrollable cards with fixed width */
        .stores-row {
            display: flex;
            overflow-x: auto;
            gap: 8px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            -webkit-overflow-scrolling: touch;
        }

        .store-item {
            flex: 0 0 auto;
            width: 120px;
            background-color: var(--cat-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            text-align: center;
            cursor: pointer;
        }
        .store-item img {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
            border-radius: inherit;   /* Div radiusini meros qilib oladi */
            display: block;           /* Pastki radiusni ham to‘g‘ri ko‘rsatadi */
        }

        .store-item .name {
            padding: 5px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Hide the popular branches section entirely per user request */
        #popularBranchesSection {
            display: none !important;
        }

        /* Popular branches use a light green background to subtly differentiate them */
        #popularBranchesSection .restaurant-card {
            background-color: var(--popular-branch-bg);
        }
        /* All branches section uses a light purple background for its cards */
        #allBranchesSection .restaurant-card {
            background-color: var(--all-branch-bg);
        }
        /* Hide the popular dishes section as it is not part of the provided design */
        #popularDishesSection {
            display: none;
        }

        .branch-type-item:hover, .food-category-item:hover {
            transform: translateY(-3px);
            /* Lighten the card on hover */
            background-color: var(--white);
        }

        .branch-type-item img,
        .food-category-item img {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
            border-radius: inherit;  /* Div radiusini meros qiladi */
            display: block;          /* Radius to‘liq ishlashi uchun */
        }


        .branch-type-item .name, .food-category-item .name {
            padding: 8px;
            font-size: 15px;
            font-weight: 600;
            color: var(--dark);
        }

        /* Highlight selected branch types and categories */
        .branch-type-item.active, .food-category-item.active {
            border: 2px solid var(--primary);
            background-color: var(--white);
        }

        /* Suggestions section inside the cart modal */
        .cart-suggestions {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid var(--light-gray);
        }
        .cart-suggestions h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--dark);
        }
        .suggestion-items {
            display: flex;
            gap: 10px;
            overflow-x: auto;
        }
        .suggestion-item {
            min-width: 140px;
            background-color: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            cursor: pointer;
            flex-shrink: 0;
        }
        .suggestion-item .image {
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            background-size: cover;
            background-position: center;
            border-top-left-radius: var(--border-radius);
            border-top-right-radius: var(--border-radius);
        }
        .suggestion-item .name {
            font-size: 12px;
            font-weight: 500;
            color: var(--dark);
            padding: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .suggestion-item .price {
            font-size: 12px;
            font-weight: 600;
            color: var(--success);
            padding: 0 6px 6px;
        }

        /* Dish Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal-content {
            background-color: var(--white);
            margin: 20px auto;
            border-radius: var(--border-radius);
            overflow: hidden;
            max-width: 500px;
            width: 95%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
        }

        /* --------------------------------------------------
           Full‑screen map overlay adjustments

           The default `.modal-content` styles constrain modal
           dialogs to a fixed width and height. For the map
           overlay we want the map to occupy the entire
           viewport on both desktop and mobile. These rules
           target only the elements inside `#mapOverlay` so
           other modals continue to behave normally. The
           header is given a coloured background and the
           search bar and action buttons are positioned on
           top of the map as overlays. The map itself
           stretches from edge to edge behind them, and the
           action buttons sit in a fixed bar at the bottom
           with a subtle divider between them.
        -------------------------------------------------- */
        #mapOverlay .modal-content {
            /* Make the overlay fill the entire screen */
            position: fixed;
            top: 0;
            left: 0;
            width: 100dvw;
            height: 100vh;
            max-width: none;
            max-height: none;
            margin: 0;
            border-radius: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        #mapOverlay .modal-header {
            /* Style the header to match the provided design */
            background-color: var(--primary);
            color: var(--white);
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Search container inside the map overlay header */
        #mapOverlay .map-search-bar {
            flex-grow: 1;
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        #mapOverlay .map-search-bar input {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: var(--border-radius);
            margin-right: 10px;
            font-size: 14px;
            /* Semi‑transparent field on coloured header */
            background-color: rgba(255, 255, 255, 0.2);
            color: var(--white);
        }

        #mapOverlay .map-search-bar input::placeholder {
            color: rgba(255, 255, 255, 0.8);
        }

        #mapOverlay #mapSearchButton {
            padding: 8px 16px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 14px;
            background-color: var(--warning);
            color: var(--dark);
            cursor: pointer;
        }

        #mapOverlay #mapSearchButton:hover {
            opacity: 0.9;
        }

        /* Clear button inside the map search bar. Positioned next to the input
           field to allow users to quickly remove the typed address. */
        #mapOverlay .map-clear-btn {
            border: none;
            background: transparent;
            color: var(--white);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            margin-right: 4px;
        }
        #mapOverlay .map-clear-btn:hover {
            opacity: 0.8;
        }

        #mapOverlay .modal-header h2 {
            margin: 0;
            font-size: 18px;
        }

        .modal-close {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background-color: #ff3b30;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease;
            position: static; /* avvalgi absolute olib tashlanadi */
        }

        .modal-close i {
            font-size: 18px;
        }

        .modal-close:hover {
            background-color: #e60000;
        }

        #mapOverlay .modal-body {
            /* Let the body expand to fill the remaining space */
            position: relative;
            flex: 1;
            width: 100%;
            height: 100%;
            overflow: hidden;
            padding-bottom: calc(130px + env(safe-area-inset-bottom, 0px));
        }

        #mapOverlay #map {
            /* The map covers the entire body area */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
        }

        #mapOverlay #mapSearchInput {
            /* Position the search input on top of the map */
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            padding: 10px 15px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            background-color: var(--white);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            font-size: 16px;
        }

        /* Override the map input positioning when it is placed in the header.
           Without this rule the absolute positioning defined above pulls the
           input out of the header and places it over the map. Using a more
           specific selector ensures the input remains within the header and
           inherits the styling from `.map-search-bar input`. */
        #mapOverlay .modal-header #mapSearchInput {
            /* Reset the absolute positioning applied in the generic rule so
               the input stays inside the header. Apply its own styling to
               integrate seamlessly into the header search bar. */
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            bottom: auto;
            width: auto;
            height: auto;
            padding: 8px 12px;
            margin-right: 10px;
            border: none;
            border-radius: var(--border-radius);
            background-color: rgba(255, 255, 255, 0.2);
            color: var(--white);
            font-size: 14px;
            box-shadow: none;
        }

        #mapOverlay #mapSearchSuggestions {
            /* Suggestions dropdown appears beneath the search field */
            position: absolute;
            top: 80px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            background-color: var(--white);
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            max-height: 150px;
            overflow-y: auto;
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #useCurrentLocationOverlayBtn,
        #confirmLocationBtn {
            /* Create a fixed bottom bar with two equal buttons anchored to the viewport.
               Position them fixed so they remain visible on both desktop and mobile
               screens and are not clipped by the scrollable map container. */
            position: fixed;
            bottom: env(safe-area-inset-bottom, 0px);
            bottom: 0;
            width: 50%;
            height: 130px;
            margin: 0;
            border-radius: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            /* Use the primary colour for the bottom bar just like the header */
            background-color: var(--primary);
            color: var(--white);
            /* Remove the default location button border and border radius */
            border: none;
            border-radius: 0;
            /* Ensure buttons appear above other elements on the page */
            z-index: 2002;
        }

        #useCurrentLocationOverlayBtn {
            left: 0;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        #confirmLocationBtn {
            right: 0;
        }

        /* Hide the yellow search button in the map overlay header. Users can submit
           queries by pressing Enter in the search field, so the separate button
           is unnecessary and takes up space on small screens. */
        #mapOverlay #mapSearchButton {
            display: none;
        }

        /* --------------------------------------------------
           Full‑screen restaurants modal

           The restaurants list should fill the screen when opened from the
           bottom navigation.  By default the modal content was constrained
           to 80% of the viewport height via an inline style on the
           `<div id="restaurantsModal">` element.  Overriding those
           constraints here ensures the list occupies the entire
           viewport on both desktop and mobile devices.  We also remove
           margins and border radii so the modal sits flush with the
           viewport edges and allow vertical scrolling within the list.
        -------------------------------------------------- */
        #restaurantsModal .modal-content {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            margin: 0;
            border-radius: 0;
            overflow-y: auto;
        }

        .modal-content {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            margin: 20px auto;
            border-radius: var(--border-radius);
            overflow: hidden;
            max-width: 500px;
            width: 95%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
        }

        @media (max-width: 480px) {
            .modal-content {
                width: 100%;
                margin: 0;
                border-radius: 0;
                height: 100vh;
                max-height: 100vh;
                overflow-y: auto;
                background-color: rgba(255, 255, 255, 0.95);
            }
        }
        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            position: relative;
        }

        .modal-dish-image {
            width: 100%;
            height: 200px;
            background-size: cover;
            background-position: center;
        }
        /* ——— Yangi ko‘rinish ——— */
        .modal-header { 
        position: relative;
        display: flex;
        flex-wrap: wrap;            /* tugma yuqorida, rasm pastda bo‘lsin */
        padding: 10px;
        }

        /* tugma: katta qizil, oq matn, chapda ← ikonka */
        .modal-header .modal-close {
        order: 1;                   /* tugma birinchi qatorda */
        margin: 0 0 10px auto;      /* o‘ngga yopishtiramiz */
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background-color: #ff3b30;
        color: #fff;
        border: none;
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: background-color .3s ease;
        position: static !important;    /* eski absolute’ni bekor qiladi */
        width: auto; height: auto; border-radius: 12px; /* eski o‘lchamlarni yo‘q qiladi */
        }
        .modal-header .modal-close:hover { background-color: #e60000; }
        .modal-header .modal-close i { font-size: 18px; }

        /* rasm: ikkinchi qatorda, to‘liq kenglikda */
        .modal-header .modal-dish-image {
        order: 2;
        flex: 1 1 100%;
        }

        /* Mobil media-query’dagi eski top/right ranglarni ham bekor qilamiz */
        @media (max-width:480px){
        .modal-header .modal-close{
            top:auto !important; right:auto !important;
            background-color:#ff3b30 !important;
        }
        }

        .modal-body {
            padding: 20px;
        }

        .modal-dish-name {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .modal-dish-price {
            font-size: 20px;
            font-weight: 700;
            color: var(--success);
            margin-bottom: 15px;
        }

        .modal-dish-desc {
            color: var(--gray);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .variants-container {
            margin-bottom: 20px;
        }

        .variant-title {
            font-weight: 600;
            margin-bottom: 10px;
        }

        .variant-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            margin-bottom: 10px;
        }

        .variant-info {
            flex-grow: 1;
        }

        .variant-name {
            font-weight: 500;
        }

        .variant-price {
            color: var(--success);
            font-size: 14px;
        }

        .variant-quantity {
            display: flex;
            align-items: center;
        }

        .quantity-btn {
            width: 30px;
            height: 30px;
            border: 1px solid var(--light-gray);
            background-color: var(--white);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
        }

        .quantity-input {
            width: 40px;
            height: 30px;
            text-align: center;
            border: 1px solid var(--light-gray);
            border-left: none;
            border-right: none;
            margin: 0 -1px;
        }

        .containers-container {
            margin-bottom: 20px;
        }

        .container-title {
            font-weight: 600;
            margin-bottom: 10px;
        }

        .container-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            cursor: pointer;
            transition: var(--transition);
        }

        .container-item.selected {
            border-color: var(--primary);
            background-color: rgba(74, 107, 255, 0.05);
        }

        .container-info {
            flex-grow: 1;
        }

        .container-name {
            font-weight: 500;
        }

        .container-price {
            color: var(--success);
            font-size: 14px;
        }

        .container-radio {
            width: 18px;
            height: 18px;
            border: 2px solid var(--light-gray);
            border-radius: 50%;
            margin-left: 10px;
            position: relative;
        }

        .container-item.selected .container-radio {
            border-color: var(--primary);
        }

        .container-item.selected .container-radio::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 10px;
            height: 10px;
            background-color: var(--primary);
            border-radius: 50%;
        }

        .modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-top: 1px solid var(--light-gray);
        }

        .total-price {
            font-size: 18px;
            font-weight: 600;
        }

        .add-to-cart-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 10px 20px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .add-to-cart-btn:hover {
            background-color: #3a5bef;
        }

        /* Cart Modal */
        .cart-modal-content {
            background-color: var(--white);
            margin: 20px auto;
            border-radius: var(--border-radius);
            overflow: hidden;
            max-width: 500px;
            width: 95%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
        }

        .cart-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--light-gray);
            font-weight: 600;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cart-body {
            max-height: 400px;
            overflow-y: auto;
            padding: 0 20px;
        }

        .cart-item {
            display: flex;
            padding: 15px 0;
            border-bottom: 1px solid var(--light-gray);
        }

        .cart-item-image {
            width: 70px;
            height: 70px;
            background-size: cover;
            background-position: center;
            border-radius: var(--border-radius);
            margin-right: 15px;
        }

        .cart-item-info {
            flex-grow: 1;
        }

        .cart-item-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .cart-item-variant {
            font-size: 14px;
            color: var(--gray);
            margin-bottom: 5px;
        }

        .cart-item-container {
            font-size: 14px;
            color: var(--gray);
            margin-bottom: 5px;
        }

        .cart-item-price {
            font-weight: 600;
            color: var(--success);
        }

        .cart-item-actions {
            display: flex;
            align-items: center;
        }

        .cart-item-quantity {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .cart-item-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .container-quantity {
            color: var(--gray);
            font-size: 12px;
        }

        .container-item-quantity {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .container-item-quantity .cart-quantity-btn {
            width: 25px;
            height: 25px;
        }

        .container-item-quantity .cart-quantity-input {
            width: 30px;
            height: 25px;
        }

        .cart-item-actions {
            display: flex;
            align-items: center;
        }
        .cart-quantity-btn {
            /* Match the size of quantity selectors in the dish modal for consistency */
            width: 30px;
            height: 30px;
            border: 1px solid var(--light-gray);
            background-color: var(--white);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
        }

        .cart-quantity-input {
            /* Match the input height to the button size */
            width: 40px;
            height: 30px;
            text-align: center;
            border: 1px solid var(--light-gray);
            border-left: none;
            border-right: none;
            margin: 0 -1px;
        }

        .cart-item-remove {
            color: var(--secondary);
            cursor: pointer;
        }

        .cart-summary {
            padding: 15px 20px;
            border-top: 1px solid var(--light-gray);
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .summary-label {
            color: var(--gray);
        }

        .summary-value {
            font-weight: 600;
        }

        .discount-value {
            color: var(--success);
        }

        .total-row {
            font-size: 18px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--light-gray);
        }

        .promo-code-container {
            display: flex;
            margin: 15px 0;
        }

        .promo-code-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius) 0 0 var(--border-radius);
            font-size: 16px;
        }

        .promo-code-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            padding: 0 15px;
            cursor: pointer;
            transition: var(--transition);
        }

        .promo-code-btn:hover {
            background-color: #3a5bef;
        }

        .cart-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--light-gray);
            display: flex;
            justify-content: flex-end;
        }

        .checkout-btn {
            background-color: var(--success);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 25px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .checkout-btn:hover {
            background-color: #1aa179;
        }

        /* Checkout Modal */
        .checkout-modal-content {
            background-color: var(--white);
            margin: 20px auto;
            border-radius: var(--border-radius);
            overflow: hidden;
            max-width: 600px;
            width: 95%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
        }

        .checkout-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--light-gray);
            font-weight: 600;
            font-size: 18px;
        }

        .checkout-body {
            padding: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(74, 107, 255, 0.2);
        }

        .delivery-info {
            background-color: var(--light-gray);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
        }

        .delivery-info i {
            margin-right: 10px;
            color: var(--primary);
        }

        .map-container {
            position: relative;
            height: 200px;
            border-radius: var(--border-radius);
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid var(--light-gray);
        }

        /* Map element inside the map container fills available space */
        #map {
            height: 100%;
        }

        /* Search bar overlay on the map */
        #mapSearchInput {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            padding: 8px 12px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            background-color: var(--white);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            font-size: 14px;
        }

        .location-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .location-btn {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--light-gray);
            background-color: var(--white);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .location-btn i {
            margin-right: 5px;
        }

        .location-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .payment-methods {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .payment-method {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-size: 14px;
        }

        .payment-method i {
            display: block;
            font-size: 24px;
            margin-bottom: 5px;
            color: var(--gray);
        }

        .payment-method.selected {
            border-color: var(--primary);
            background-color: rgba(74, 107, 255, 0.05);
        }

        .payment-method.selected i {
            color: var(--primary);
        }

        .checkout-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--light-gray);
            display: flex;
            justify-content: flex-end;
        }

        .place-order-btn {
            background-color: var(--success);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 25px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .place-order-btn:hover {
            background-color: #1aa179;
        }

        /* Success Modal */
        .success-modal-content {
            background-color: var(--white);
            margin: 20px auto;
            border-radius: var(--border-radius);
            overflow: hidden;
            max-width: 400px;
            width: 95%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
            text-align: center;
            padding: 30px 20px;
        }

        .success-icon {
            font-size: 60px;
            color: var(--success);
            margin-bottom: 20px;
        }

        .success-title {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .success-message {
            color: var(--gray);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .success-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 25px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .success-btn:hover {
            background-color: #3a5bef;
        }

        /* Closed Modal */
        .closed-modal-content {
            background-color: var(--white);
            margin: 20px auto;
            border-radius: var(--border-radius);
            overflow: hidden;
            max-width: 400px;
            width: 95%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
            text-align: center;
            padding: 30px 20px;
        }

        .closed-icon {
            font-size: 60px;
            color: #09ff00;
            margin-bottom: 20px;
        }

        .closed-title {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .closed-message {
            color: var(--gray);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .closed-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 25px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .closed-btn:hover {
            background-color: #3a5bef;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-around;
            padding: 1px 0;
            /* Lower the z-index so that modals appear above the navigation bar.
               Modals use a z-index of 1000; set the bottom nav below that. */
            z-index: 900;
            border-top: 0px solid rgba(0, 0, 0, 0.1);
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: rgba(0, 0, 0, 0.7);
            font-size: 12px;
            transition: var(--transition);
            padding: 5px 10px;
            border-radius: 10px;
        }

        .nav-item i {
            font-size: 20px;
            margin-bottom: 5px;
            color: rgba(0, 0, 0, 0.7);
        }

        .nav-item.active {
            color: var(--primary);
            background-color: rgba(74, 107, 255, 0.1);
        }

        .nav-item.active i {
            color: var(--primary);
        }

        .delivery-info-bottom {
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 10px 15px;
            font-size: 12px;
            text-align: center;
            position: fixed;
            bottom: 60px;
            left: 0;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .delivery-info-bottom i {
            margin-right: 5px;
            color: var(--primary);
        }

        /* Indicator showing how many products a branch contains. Appears next
           to the branch name in the list. */
        .more-count {
            margin-left: 6px;
            font-size: 14px;
            color: var(--gray);
        }
        .restaurant-name:hover .more-count {
            color: var(--primary);
        }

        /* Chat modal styling for the Kago agent. This modal uses the same
           overlay as other modals but its content is a vertical flex
           container with a header, scrollable message area and input row. */
        #agentModal .modal-content {
            display: flex;
            flex-direction: column;
            max-width: 400px;
            width: 95%;
            height: 70vh;
        }
        #agentModal .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid var(--light-gray);
            font-weight: 600;
        }
        #agentModal .chat-body {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: var(--light);
        }
        #agentModal .chat-input {
            display: flex;
            padding: 10px;
            border-top: 1px solid var(--light-gray);
            background-color: var(--white);
        }
        #agentInput {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            font-size: 14px;
        }
        #agentSendBtn {
            margin-left: 10px;
            padding: 8px 16px;
            background-color: var(--primary);
            color: var(--white);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
        }
        #agentSendBtn:hover {
            background-color: #00cc5c;
        }
        /* Message bubbles */
        .chat-message {
            margin-bottom: 10px;
            display: flex;
        }
        .chat-message.user {
            justify-content: flex-end;
        }
        .chat-message.agent {
            justify-content: flex-start;
        }
        .chat-message .bubble {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 15px;
            line-height: 1.3;
            word-wrap: break-word;
        }
        .chat-message.user .bubble {
            background-color: var(--primary);
            color: var(--white);
            border-bottom-right-radius: 2px;
        }
        .chat-message.agent .bubble {
            background-color: var(--light-gray);
            color: var(--dark);
            border-bottom-left-radius: 2px;
        }
        .chat-header .close-chat {
            cursor: pointer;
            font-size: 20px;
        }

        /* Responsive adjustments for mobile: place search next to logo */
        @media (max-width: 600px) {
            .header-content {
                flex-wrap: nowrap;
            }
            .search-container {
                flex: 1;
                margin-left: 10px;
            }
            .search-input {
                font-size: 14px;
            }
        }

        .container-item .variant-quantity {
            display: flex;
            align-items: center;
            margin-left: 10px;
        }

        .container-item .quantity-btn {
            width: 25px;
            height: 25px;
            border: 1px solid var(--light-gray);
            background-color: var(--white);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
        }

        .container-item .quantity-input {
            width: 30px;
            height: 25px;
            text-align: center;
            border: 1px solid var(--light-gray);
            border-left: none;
            border-right: none;
            margin: 0 -1px;
        }

        /* Update cart item actions styles */
        .cart-item-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-left: 10px;
        }

        .cart-item-quantity, .container-item-quantity {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .cart-quantity-btn {
            width: 25px;
            height: 25px;
            border: none;
            background-color: var(--primary);
            color: #fff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            transition: var(--transition);
        }

        .cart-quantity-input {
            width: 30px;
            height: 25px;
            text-align: center;
            border: 1px solid var(--light-gray);
            border-left: none;
            border-right: none;
            margin: 0 -1px;
        }

        .cart-item-remove {
            color: var(--secondary);
            cursor: pointer;
            margin-top: 5px;
        }

        /* Make cart items more compact on mobile */
        @media (max-width: 480px) {
            .cart-item {
                padding: 10px 0;
            }
            
            .cart-item-image {
                width: 50px;
                height: 50px;
                margin-right: 10px;
            }
            
            .cart-item-name {
                font-size: 14px;
            }
            
            .cart-item-variant, .cart-item-container {
                font-size: 12px;
            }
            
            .cart-item-price {
                font-size: 14px;
            }
            
            .cart-item-actions {
                margin-left: 5px;
            }
            
            .cart-quantity-btn {
                width: 20px;
                height: 20px;
                font-size: 12px;
            }
            
            .cart-quantity-input {
                width: 25px;
                height: 20px;
                font-size: 12px;
            }
        }

        /* Promo code styles */
        .promo-code-container {
            display: flex;
            margin: 15px 0;
        }

        .promo-code-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius) 0 0 var(--border-radius);
            font-size: 16px;
        }

        .promo-code-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            padding: 0 15px;
            cursor: pointer;
            transition: var(--transition);
        }

        /* Mobile optimizations for promo code */
        @media (max-width: 480px) {
            .promo-code-container {
                flex-direction: column;
                gap: 10px;
                margin: 10px 0;
            }
            
            .promo-code-input {
                border-radius: var(--border-radius);
                padding: 8px 12px;
                font-size: 14px;
            }
            
            .promo-code-btn {
                border-radius: var(--border-radius);
                padding: 8px 12px;
                width: 100%;
            }
        }

        /* ---------- Custom enhancements ---------- */
        /* Horizontal scrolling for dishes inside restaurant cards */
        .restaurant-dishes {
            display: flex;
            overflow-x: auto;
            padding: 0 15px 15px;
            gap: 15px;
        }
        /* Hide horizontal scrollbar background on WebKit browsers */
        .restaurant-dishes::-webkit-scrollbar {
            height: 6px;
        }
        .restaurant-dishes::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        /* Ensure each dish card in slider has fixed width */
        .restaurant-dishes .dish-card {
            /* Reduce dish card width so more items fit on small screens (approx. 2.5 cards visible at once) */
            flex: 0 0 140px;
        }
        /* Beautify quantity buttons */
        .quantity-btn,
        .cart-quantity-btn,
        .container-item .quantity-btn {
            background-color: var(--primary);
            color: #fff;
            border: none;
            border-radius: 4px;
            transition: var(--transition);
        }
        .quantity-btn:hover,
        .cart-quantity-btn:hover,
        .container-item .quantity-btn:hover {
            background-color: #3a5bef;
        }
        /* Style inputs next to quantity buttons */
        .quantity-input,
        .cart-quantity-input,
        .container-item .quantity-input {
            border: 1px solid var(--light-gray);
            text-align: center;
        }
        /* Increase bottom padding to prevent bottom overlays covering content */
        body {
            padding-bottom: 160px;
        }
        /* Ensure delivery info bottom stays below other elements */
        .delivery-info-bottom {
            z-index: 50;
        }
        /* Responsive Styles */
        /* --- Header: kichik ekranda ham bitta qatorda --- */
        @media (max-width: 768px) {
            /* Grid — auto | 1fr | auto: logo | qidirish | B2B */
            .header-content {
                display: grid;
                grid-template-columns: auto 1fr auto;
                align-items: center;
                gap: 8px;
            }

            /* Elementlar o‘lchami ixchamroq bo‘lsin */
            .logo img { height: 32px; }

            .search-container {
                min-width: 0;          /* shrink bo‘lishi uchun muhim */
                margin: 0;             /* bo‘shliqni kamaytiramiz */
            }
            .search-input {
                font-size: 14px;
                padding: 8px 12px 8px 36px; /* ikonka uchun joy qoldiramiz */
            }
            .search-icon { left: 10px; }

            /* B2B tugma ixcham: uzunlashib ketmasin, qatorni buzmasin */
            .b2b-btn {
                padding: 6px 10px;
                font-size: 12px;
                border-radius: 12px;
                max-width: 72px;       /* juda cho‘zilib ketmasin */
                text-align: center;
                white-space: nowrap;   /* satr buzilmasin */
            }
        }

        @media (max-width: 480px) {
            .restaurants-container {
                grid-template-columns: 1fr;
            }

            .dishes-container {
                /* On very narrow screens make dishes narrower so at least three
                   items fit on a single row.  A minimum of 90px allows
                   three cards plus gaps on 360px wide devices. */
                grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            }

            .modal-content, .cart-modal-content, .checkout-modal-content {
                width: 100%;
                margin: 0;
                border-radius: 0;
                height: 100vh;
                max-height: 100vh;
                overflow-y: auto;
            }

            .modal-close {
                top: 15px;
                right: 15px;
                background-color: rgba(0, 0, 0, 0.7);
            }
        }

        /* === Kategoriyalarni kichraytirish (mobilga ~5.5 dona) === */
        @media (max-width: 480px) {
        /* Kategoriyalar (gorizontal skroll) — item eni responsiv */
        .food-categories {
            gap: 6px; /* biroz kichikroq oraliq */
        }
        .food-category-item {
            /* 5.5 dona sig‘ishi uchun ~18% */
            width: calc((100vw - 15px) / 5.5);
            max-width: 92px;   /* juda katta bo‘lib ketmasin */
            min-width: 64px;   /* juda kichrayib ketmasin */
        }
        .food-category-item .name {
            font-size: 11px;   /* matnni ham ixchamlashtiramiz */
            padding: 4px;
        }

        /* Doʻkonlar qatordagi kartalar ham bir xil sara ko‘rinsin */
        .stores-row { gap: 6px; }
        .store-item {
            width: calc((100vw - 15px) / 5.5);
            max-width: 92px;
            min-width: 64px;
        }
        .store-item .name {
            font-size: 11px;
            padding: 4px;
        }
        }

        /* Ensure the agent chat modal becomes full screen on small
           devices.  This override must be placed at the end of the
           stylesheet so that it supersedes earlier definitions. */
        @media (max-width: 600px) {
            /* On small screens the AI chat should occupy the full viewport
               without any margin or border radius.  Overriding margin
               prevents leftover spacing from the default rules. */
            #agentModal .modal-content {
                max-width: none !important;
                width: 100% !important;
                height: 100% !important;
                margin: 0 !important;
                border-radius: 0 !important;
            }
        }

    </style>
</head>
<body>
    <!-- Splash screen overlay.  Displays a full‑screen brand logo during initial load.  The overlay
         fades away after a short delay (handled in the script below). -->
    <div id="splashScreen" style="display: flex; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: #c1ff72; align-items: center; justify-content: center; z-index: 10000;">
        <img src="logo.png" alt="KAGO" style="width: 150px; height: auto; animation: splashZoom 2s ease-out forwards;">
    </div>
    <!-- Header -->
    <header>
        <div class="container">
            <div class="header-content">
                <a href="#" class="logo">
                    <img src="logo.png" alt="KAGO" style="height:40px;">
                </a>
                
                <div class="search-container">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" class="search-input" placeholder="Qidirish...">
                </div>
                
                <!-- Insert B2B button on the right side of the header.  This opens the admin panel in a new tab. -->
                <a href="https://kagoo.uz/admin.html" class="b2b-btn" target="_blank" rel="noopener">B2B</a>
                
                <!-- Header actions removed per request; favorites and cart are accessible via bottom navigation -->
            </div>
        </div>
    </header>

    <!-- Hero Slider -->
    <div class="container">
        <div class="hero-slider" id="heroSlider">
            <!-- Slides will be dynamically injected here -->
        </div>
    </div>

    <!-- Main Content -->
    <div class="container">
        <!-- Food Categories Section: shows dish categories with images and names. -->
        <div id="foodCategoriesSection" style="margin-top: 20px;">
            <h2 class="section-title">Kategoriyalar ➯</small></h2>
            <div id="foodCategoriesRow" class="food-categories" style="margin-top: 10px;"></div>
        </div>

    <!-- Stores Section: lists all stores (restaurants) with image and name.  This section appears
         immediately after categories and scrolls horizontally when there are many stores. -->
    <div id="storesSection" style="margin-top: 20px;">
        <h2 class="section-title">Doʻkonlar ➯</small></h2>
        <div id="storesRow" class="stores-row" style="margin-top: 10px;"></div>
    </div>
        <!-- Branch Types Section: shows different types of branches. -->
        <div id="branchTypesSection" style="margin-top: 20px;">
            <h2 class="section-title">Filial&nbsp;turlari</small></h2>
            <div id="branchTypesRow" class="branch-types" style="margin-top: 10px;"></div>
        </div>
        <!-- Popular Branches Section: highlights the most ordered branches. -->
        <div id="popularBranchesSection" style="margin-top: 20px;">
            <h2 class="section-title">Mashhur&nbsp;filiallar</small></h2>
            <div class="restaurants-container" id="popularBranches"></div>
        </div>
        <!-- All Branches Section: lists all available branches. -->
        <div id="allBranchesSection" style="margin-top: 20px;">
            <h2 class="section-title">Filiallar</small></h2>
            <div id="restaurantsList"></div>
        </div>
        <!-- Popular Dishes Section retained for backward compatibility; hidden via CSS. -->
        <div id="popularDishesSection" style="display:none;"></div>
    </div>



<!-- Doʻkonlar modal oynasi -->
<div class="modal" id="restaurantsModal">
<div class="modal-content">
        <div class="modal-header">
            <h2>      Doʻkonlar</h2>
            <button class="modal-close" id="closeRestaurantsModal">
            <i class="fa-solid fa-circle-xmark"></i> 
            </button>
        </div>
        <div class="modal-body" id="restaurantsModalContent">
            <!-- Doʻkonlar bu yerda ko'rsatiladi -->
        </div>
    </div>
</div>

    <!-- Bottom Navigation -->
    <div class="bottom-nav">
        <a href="#" class="nav-item active">
            <i class="fas fa-home"></i>
            <span>Bosh sahifa</span>
        </a>
        <a href="#" class="nav-item">
            <i class="fas fa-store"></i>
            <span>Doʻkonlar</span>
        </a>
        <a href="#" class="nav-item" id="favoritesNavBtn">
            <i class="fas fa-heart"></i>
            <span>Sevimli</span>
        </a>
        <a href="#" class="nav-item" id="cartNavBtn">
            <span style="position:relative;">
                <i class="fas fa-shopping-cart"></i>
                <span class="cart-count">0</span>
            </span>
            <span>Savat</span>
        </a>

        <!-- Kago AI agent navigation item. Opens chat modal when tapped. -->
        <a href="#" class="nav-item" id="agentNavBtn">
            <i class="fa-solid fa-headset"></i>
            <span>Kago AI</span>
        </a>

    </div>

    <!-- Dish Modal -->
    <div class="modal" id="dishModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-dish-image" id="modalDishImage"></div>
                <button class="modal-close" id="closeDishModal">
                <i class="fa-solid fa-circle-xmark"></i> 
                </button>
            </div>
            <div class="modal-body">
                <h2 class="modal-dish-name" id="modalDishName"></h2>
                <div class="modal-dish-price" id="modalDishPrice"></div>
                <p class="modal-dish-desc" id="modalDishDesc"></p>
                
                <div class="variants-container" id="variantsContainer">
                    <div class="variant-title">Variantlar</div>
                    <!-- Variants will be loaded here -->
                </div>
                
                <div class="containers-container" id="containersContainer">
                    <div class="container-title">Idishlar</div>
                    <!-- Containers will be loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <div class="total-price" id="dishTotalPrice">0 UZS</div>
                <button class="add-to-cart-btn" id="addToCartBtn">Savatga qo'shish</button>
            </div>
        </div>
    </div>

    <!-- Cart Modal -->
    <div class="modal" id="cartModal">
        <div class="cart-modal-content">
            <div class="cart-header">
                <span>Savat</span>
                <button class="modal-close" id="closeCartModal">
                <i class="fa-solid fa-circle-xmark"></i> 
                </button>
            </div>
            <div class="cart-body" id="cartItemsContainer">
                <!-- Cart items will be loaded here -->
            </div>
            <div class="cart-summary">
                <div class="summary-row">
                    <span class="summary-label">Mahsulotlar narxi:</span>
                    <span class="summary-value" id="subtotalPrice">0 UZS</span>
                </div>
                <div class="summary-row">
                    <span class="summary-label">Idishlar narxi:</span>
                    <span class="summary-value" id="containersPrice">0 UZS</span>
                </div>
                <!-- Hidden delivery and promo code fields inside cart summary. Delivery is now calculated in checkout modal. -->
                <div class="summary-row" id="discountRow" style="display: none;">
                    <span class="summary-label">Chegirma:</span>
                    <span class="summary-value discount-value" id="discountPrice">-0 UZS</span>
                </div>

                <div class="summary-row total-row">
                    <span class="summary-label">Jami:</span>
                    <span class="summary-value" id="totalPrice">0 UZS</span>
                </div>
            </div>
            <div class="cart-footer">
                <button class="checkout-btn" id="checkoutBtn">Buyurtma berish</button>
            </div>
        </div>
    </div>

    <!-- Checkout Modal -->
    <div class="modal" id="checkoutModal">
        <div class="checkout-modal-content">
            <div class="checkout-header">
                <span>Buyurtma berish</span>
                <button class="modal-close" id="closeCheckoutModal">
                <i class="fa-solid fa-circle-xmark"></i> Orqaga qaytish
                </button>
            </div>
            <div class="checkout-body">
                <div class="form-group">
                    <label for="customerName" class="form-label">Ismingiz?</label>
                    <input type="text" class="form-control" id="customerName" required>
                </div>
                <div class="form-group">
                    <label for="customerPhone" class="form-label">Telefon raqamingiz?</label>
                    <input type="tel" class="form-control" id="customerPhone" required>
                </div>
                <div class="form-group">
                    <label for="customerNote" class="form-label">Kuryer uchun izoh (ixtiyoriy)</label>
                    <textarea class="form-control" id="customerNote" rows="3"></textarea>
                </div>
                
                <div class="delivery-info">
                    <i class="fas fa-info-circle"></i>
                    Yetkazib berish dastlabki 3 km uchun 10,000 UZS, keyingi har bir km uchun 1,800 UZS. (Min. buyurtma 20,000 UZS)
                </div>
                
                <div class="form-group">
                    <label class="form-label">Yetkazib berish manzilini belgilang</label>
                    <!-- Location selection controls: map is now opened in a full-screen overlay when needed. -->
                    <div class="location-buttons">
                        <button class="location-btn" id="selectLocationBtn">
                            <i class="fas fa-map-marked-alt"></i> Xaritadan tanlash
                        </button>
                        <button class="location-btn" id="useCurrentLocationBtn">
                            <i class="fas fa-location-arrow"></i> GPS joylashuv
                        </button>
                    </div>
                    <!-- Container to show the user's last saved address -->
                    <div id="lastLocationContainer" style="font-size: 12px; color: var(--gray); margin-top: 5px;"></div>
                    <input type="text" class="form-control" id="locationInput" placeholder="Manzil" readonly>
                </div>

                <!-- Promo code input appears in checkout instead of cart -->
                <div class="form-group" id="promoCodeGroup">
                    <label class="form-label" for="checkoutPromoCodeInput">Promo kod bormi?</label>
                    <div class="promo-code-container">
                        <input type="text" class="promo-code-input" id="checkoutPromoCodeInput" placeholder="Promo kod kiritish">
                        <button class="promo-code-btn" id="checkoutApplyPromoCodeBtn">Qo'llash</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">To'lov usuli</label>
                    <div class="payment-methods">
                        <div class="payment-method selected" data-method="cash">
                            <i class="fas fa-money-bill-wave"></i>
                            Naqd pul
                        </div>
                        <div class="payment-method" data-method="card">
                            <i class="fas fa-credit-card"></i>
                            Karta orqali
                        </div>
                    </div>
                </div>

                <!-- Order summary (foods, containers and delivery) displayed under payment methods -->
                <div class="form-group" id="orderSummaryGroup">
                    <div class="summary-row">
                        <span class="summary-label">Buyurtma narxi:</span>
                        <span class="summary-value" id="checkoutSubtotal">0 UZS</span>
                    </div>
                    <div class="summary-row">
                        <span class="summary-label">Idishlar narxi:</span>
                        <span class="summary-value" id="checkoutContainers">0 UZS</span>
                    </div>
                    <div class="summary-row">
                        <span class="summary-label">Yetkazib berish narxi:</span>
                        <span class="summary-value" id="checkoutDelivery">0 UZS</span>
                    </div>
                    <!-- Total row showing the final price including all costs and discounts -->
                    <div class="summary-row total-row">
                        <span class="summary-label">Jami narx:</span>
                        <span class="summary-value" id="checkoutTotal">0 UZS</span>
                    </div>
                </div>
            </div>
            <div class="checkout-footer">
                <button class="place-order-btn" id="placeOrderBtn">Buyurtmani tasdiqlash</button>
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div class="modal" id="successModal">
        <div class="success-modal-content">
            <div class="success-icon">
                <i class="fas fa-check-circle"></i>
            </div>
            <h2 class="success-title">Buyurtmangiz qabul qilindi!</h2>
            <p class="success-message">Buyurtmangiz holatini pastdagi tugmani bosish orqali telegram botimizda kuzatishingiz mumkin!</p>
            <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
                <button class="success-btn" id="trackOrderBtn">Kuzatish</button>
                <button class="success-btn" id="closeSuccessModal">Yopish</button>
            </div>
        </div>
    </div>

    <!-- Map Selection Overlay -->
    <!--
        A full‑screen modal used for selecting the delivery location on a map.
        The map includes a search bar for address lookup, a list of suggestions
        while typing, and buttons for using the device's current location and
        confirming the selected point. This overlay is hidden by default and
        displayed when the user taps the "Xaritadan tanlash" button in the
        checkout form.
    -->
    <div class="modal" id="mapOverlay" style="z-index: 3000;">
        <!-- The map overlay's content uses full‑screen styles defined in the CSS.  -->
        <div class="modal-content">
            <div class="modal-header">
                <h2> </h2>
                <!-- Search bar added to the header for a compact layout on both desktop and mobile -->
                <div class="map-search-bar">
                    <input type="text" id="mapSearchInput" placeholder="Manzilni qidirish">
                    <!-- Clear search button to remove typed text -->
                    <button type="button" id="mapClearButton" class="map-clear-btn">&times;</button>
                    <button id="mapSearchButton">Qidirish</button>
                </div>
                <!-- Removed close button on the map overlay. The overlay can be closed by using the confirm button below -->
            </div>
            <div class="modal-body">
                <!-- Search bar for map overlay -->
                <!-- Search input moved to the header -->
                <!-- Suggestions dropdown for map search -->
                <ul id="mapSearchSuggestions" style="display:none;"></ul>
                <!-- Map container for full‑screen map -->
                <div id="map" style="width:100%; height:100%;"></div>
                <!-- Buttons on top of the map.  Their positioning and appearance
                     are defined in the CSS so they form a bottom bar. -->
                <button class="location-btn" id="useCurrentLocationOverlayBtn"> <i class="fas fa-location-arrow"></i> GPS joylashuv</button>
                <button class="location-btn" id="confirmLocationBtn">  Belgilash va Yopish </button>
            </div>
        </div>
    </div>

    <!-- Kago Kago AI Chat Modal -->
    <!--
        This modal hosts the conversational AI assistant. It appears on top of
        the page when the user taps the "Kago AI" button in the bottom
        navigation. The header displays the assistant name and includes a
        close button. Below that is a scrollable area showing the
        conversation history. At the bottom is an input row with a text
        field and send button. Messages from the user and the agent are
        styled differently.
    -->
    <div class="modal" id="agentModal">
        <div class="modal-content">
            <div class="chat-header">
                <span>Kago AI yordamchi</span>
                <span class="close-chat" id="closeAgentModal">&times;</span>
            </div>
            <div class="chat-body" id="agentMessages"></div>
            <div class="chat-input">
                <input type="text" id="agentInput" placeholder="Savolingizni kiriting...">
                <button id="agentSendBtn">➤</button>
            </div>
        </div>
    </div>

    <!-- Closed Modal -->
    <div class="modal" id="closedModal">
        <div class="closed-modal-content">
            <div class="closed-icon">
                <i class="fas fa-clock"></i>
            </div>
            <!-- Title explaining that the business is currently closed -->
            <h2 class="closed-title">Kechirasiz, hozir dam olyapmiz!</h2>
            <!-- Message informing the user they can browse and add items but cannot place an order -->
            <p class="closed-message">Hozir buyurtmalar qabul qilinmaydi. Siz mahsulotlarni savatga qo'shishingiz mumkin, ammo buyurtma faqat ish vaqtida beriladi.</p>
            <!-- Collapsible work hours information; hidden by default -->
            <div id="workHoursInfo" style="display:none; margin-top:10px; font-size:14px; text-align:left;"></div>
            <!-- Modal actions: show schedule and close -->
            <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                <button class="closed-btn" id="showWorkHoursBtn">Ish Vaqti</button>
                <button class="closed-btn" id="closeClosedModal">Tushundim</button>
            </div>
        </div>
    </div>

    <!-- Branch Closed Modal -->
    <!--
      When a specific restaurant’s opening hours have elapsed, we still show
      the branch in most areas of the site but clicking on it should not
      open its menu.  Instead a simple modal informs the user that the
      branch is closed today and displays the start and end time set by
      the administrator.  The content of this modal is filled at
      runtime.
    -->
    <div class="modal" id="branchClosedModal">
        <div class="closed-modal-content">
            <div class="closed-icon">
                <i class="fas fa-clock"></i>
            </div>
            <!-- Title and message populated by JavaScript -->
            <h2 class="closed-title" id="branchClosedTitle">Filial yopiq</h2>
            <p class="closed-message" id="branchClosedMessage"></p>
            <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                <button class="closed-btn" id="closeBranchClosedModal">Tushundim</button>
            </div>
        </div>
    </div>

    <!-- Load Yandex Maps API -->
    <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU" type="text/javascript"></script>
    <script>
    window.API_BASE_URL = window.location.origin + '/api';
        // API Base URL
        const API_BASE_URL = '/api';
        
        // Global variables
        let restaurants = [];
        let dishes = [];
        let containers = [];
        let promocodes = [];
        let cart = [];
        let favorites = [];
        let currentDish = null;
        let selectedVariant = null;
        let selectedContainer = null;
        let selectedPaymentMethod = 'cash';
        let userLocation = null;
        let map = null;
        let marker = null;
        let isBusinessHours = true;

        // Tracks how many active container options are available for the currently opened dish.
        // This is used to determine whether a container selection is required when adding to cart.
        let availableContainerCount = 0;

        // Preserve a consistent random order of restaurants for the duration of a session.
        // When the page first loads, restaurants are shuffled once and stored in this array.
        // Navigating between pages or opening/closing modals should not reshuffle them.
        let shuffledRestaurantsOrder = null;

        // Work hours schedule (populated from server)
        let workHours = {};

        // Per‑branch opening hours (populated from server).  Each key is a
        // restaurant ID and maps to an object with `start` and `end`
        // properties (e.g. { start: '08:00', end: '22:00' }).  If a
        // restaurant ID is missing from this object the branch is
        // considered always open.
        let branchTimes = {};

        // Branch types and food categories (populated from server). These arrays
        // will hold objects with id, name, active and optional image properties.
        let branchTypes = [];
        let categories = [];

        // Currently selected branch type and category filters. A null value
        // indicates no filter is applied. When a branch type is selected
        // the category filter is reset, and vice versa.
        let selectedBranchTypeId = null;
        let selectedCategoryId = null;
        
        // DOM Elements
        const heroSlider = document.getElementById('heroSlider');
        const restaurantsList = document.getElementById('restaurantsList');
        const searchInput = document.querySelector('.search-input');

        // Rows for branch types and food categories
        const branchTypesRow = document.getElementById('branchTypesRow');
        const foodCategoriesRow = document.getElementById('foodCategoriesRow');

        // Row for stores (Do'konlar) and its container
        const storesRow = document.getElementById('storesRow');
        const storesSection = document.getElementById('storesSection');

        // Section containers (used to hide/show when searching)
        const branchTypesSection = document.getElementById('branchTypesSection');
        const foodCategoriesSection = document.getElementById('foodCategoriesSection');
        const popularBranchesSection = document.getElementById('popularBranchesSection');
        const popularDishesSection = document.getElementById('popularDishesSection');
        const allBranchesSection = document.getElementById('allBranchesSection');

        // Containers for popular branches and dishes
        const popularBranchesEl = document.getElementById('popularBranches');
        const popularDishesEl = document.getElementById('popularDishes');
        
        // Modal elements
        const dishModal = document.getElementById('dishModal');
        const cartModal = document.getElementById('cartModal');
        const checkoutModal = document.getElementById('checkoutModal');
        const successModal = document.getElementById('successModal');
        const closedModal = document.getElementById('closedModal');
        
        const closeDishModalBtn = document.getElementById('closeDishModal');
        const closeCartModalBtn = document.getElementById('closeCartModal');
        const closeCheckoutModalBtn = document.getElementById('closeCheckoutModal');
        const closeSuccessModalBtn = document.getElementById('closeSuccessModal');
        const closeClosedModalBtn = document.getElementById('closeClosedModal');

        // Work hours modal elements
        const showWorkHoursBtn = document.getElementById('showWorkHoursBtn');
        const workHoursInfoEl = document.getElementById('workHoursInfo');
        
        // Cart elements
        // The header cart button has been removed. Fallback to the bottom navigation cart button
        const cartBtn = document.getElementById('cartBtn') || document.getElementById('cartNavBtn');
        const cartNavBtn = document.getElementById('cartNavBtn') || document.getElementById('cartBtn');
        const cartCount = document.querySelector('.cart-count');
        const cartItemsContainer = document.getElementById('cartItemsContainer');
        const subtotalPrice = document.getElementById('subtotalPrice');
        const containersPrice = document.getElementById('containersPrice');
        const deliveryPrice = document.getElementById('deliveryPrice');
        const discountRow = document.getElementById('discountRow');
        const discountPrice = document.getElementById('discountPrice');
        const totalPrice = document.getElementById('totalPrice');
        const promoCodeInput = document.getElementById('promoCodeInput');
        const applyPromoCodeBtn = document.getElementById('applyPromoCodeBtn');
        const checkoutBtn = document.getElementById('checkoutBtn');
        
        // Dish modal elements
        const modalDishImage = document.getElementById('modalDishImage');
        const modalDishName = document.getElementById('modalDishName');
        const modalDishPrice = document.getElementById('modalDishPrice');
        const modalDishDesc = document.getElementById('modalDishDesc');
        const variantsContainer = document.getElementById('variantsContainer');
        const containersContainer = document.getElementById('containersContainer');
        const dishTotalPrice = document.getElementById('dishTotalPrice');
        const addToCartBtn = document.getElementById('addToCartBtn');
        
        // Checkout elements
        const customerName = document.getElementById('customerName');
        const customerPhone = document.getElementById('customerPhone');
        const customerNote = document.getElementById('customerNote');
        const mapContainer = document.getElementById('map');
        const locationInput = document.getElementById('locationInput');
        const selectLocationBtn = document.getElementById('selectLocationBtn');
        const useCurrentLocationBtn = document.getElementById('useCurrentLocationBtn');
        const paymentMethods = document.querySelectorAll('.payment-method');
        const placeOrderBtn = document.getElementById('placeOrderBtn');

        // Checkout promo code elements
        const checkoutPromoCodeInput = document.getElementById('checkoutPromoCodeInput');
        const checkoutApplyPromoCodeBtn = document.getElementById('checkoutApplyPromoCodeBtn');

        // Checkout summary elements
        const checkoutSubtotal = document.getElementById('checkoutSubtotal');
        const checkoutContainers = document.getElementById('checkoutContainers');
        const checkoutDelivery = document.getElementById('checkoutDelivery');

        // Success modal track button
        const trackOrderBtn = document.getElementById('trackOrderBtn');
        
        // Favorites elements
        const favoritesBtn = document.getElementById('favoritesBtn');
        const favoritesNavBtn = document.getElementById('favoritesNavBtn');

        // Map overlay elements for selecting location
        const mapOverlay = document.getElementById('mapOverlay');
        const closeMapOverlayBtn = document.getElementById('closeMapOverlay');
        const confirmLocationBtn = document.getElementById('confirmLocationBtn');
        const useCurrentLocationOverlayBtn = document.getElementById('useCurrentLocationOverlayBtn');
        const mapSearchSuggestions = document.getElementById('mapSearchSuggestions');
        
        // Initialize page on load: fetch work hours, then check business hours and load data
        document.addEventListener('DOMContentLoaded', async function() {
            // Hide the splash screen after a brief delay to reveal the app.  The splash
            // overlay is purely cosmetic and does not block the rest of the page from
            // loading.  A timeout ensures users always see the brand momentarily.
            setTimeout(function() {
                const splash = document.getElementById('splashScreen');
                if (splash) splash.style.display = 'none';
            }, 2000);

            // Remove automatic dark‑mode toggling.  The site now always uses the light
            // theme, so we no longer apply or remove a dark-mode class based on
            // current time.

            // Fetch work hours schedule from server
            await fetchWorkHours();
            // Determine if business is open
            checkBusinessHours();
            // Load initial data regardless of business hours
            loadInitialData();
            // Initialize hero slider
            initHeroSlider();
            
            // Load favorites from localStorage
            const savedFavorites = localStorage.getItem('favorites');
            if (savedFavorites) {
                favorites = JSON.parse(savedFavorites);
            }
            
            // Load cart from localStorage
            const savedCart = localStorage.getItem('cart');
            if (savedCart) {
                cart = JSON.parse(savedCart);
                updateCartCount();
            }

            // Initialise browser history with a default state. This prevents the
            // browser back button from immediately leaving the site. All further
            // navigation within the app pushes additional states. After replacing
            // the current history entry, push a second entry so that pressing
            // the back button while an overlay (e.g., the map) is open will
            // close the overlay instead of exiting the site entirely.
            try {
                history.replaceState({ page: 'home' }, '', '');
                history.pushState({ page: 'home' }, '', '');
            } catch (_) {}

            // Restore last selected delivery address, if any
            const lastAddress = localStorage.getItem('lastAddress');
            const lastCoords = localStorage.getItem('lastCoords');
            if (lastAddress) {
                const lastContainer = document.getElementById('lastLocationContainer');
                if (lastContainer) {
                    lastContainer.textContent = `SIZNING MANZILINGIZ: ${lastAddress}`;
                }
                // Pre-fill location input if it exists
                const locInput = document.getElementById('locationInput');
                if (locInput && !locInput.value) {
                    locInput.value = lastAddress;
                }
                // Set userLocation from stored coordinates
                if (lastCoords) {
                    try {
                        const coords = JSON.parse(lastCoords);
                        userLocation = coords;
                    } catch (_) {}
                }
            }
        });
        
        // Check if current time is within business hours (8:30 - 23:59)
        /**
         * Fetch work hours schedule from the backend. The response is expected to be
         * an object where keys are days of the week (e.g., 'monday') and values
         * contain `start` and `end` properties (strings in HH:MM format). If
         * fetching fails, workHours remains an empty object and default hours
         * will be assumed in checkBusinessHours().
         */
        async function fetchWorkHours() {
            try {
                const res = await fetch(`${API_BASE_URL}/workhours`);
                if (res.ok) {
                    workHours = await res.json();
                } else {
                    console.error('Failed to fetch work hours');
                }
            } catch (err) {
                console.error('Failed to fetch work hours:', err);
            }
        }

        /**
         * Populate the work hours information inside the closed modal. This
         * function builds a simple list of days with their start and end times.
         */
        function populateWorkHoursInfo() {
            const infoEl = document.getElementById('workHoursInfo');
            if (!infoEl) return;
            // Only populate if schedule exists
            if (!workHours || Object.keys(workHours).length === 0) {
                infoEl.innerHTML = '';
                return;
            }
            const dayNamesUz = {
                monday: 'Dushanba',
                tuesday: 'Seshanba',
                wednesday: 'Chorshanba',
                thursday: 'Payshanba',
                friday: 'Juma',
                saturday: 'Shanba',
                sunday: 'Yakshanba'
            };
            let html = '<strong>Ish vaqti:</strong><br>';
            Object.keys(dayNamesUz).forEach(key => {
                const dayData = workHours[key] || {};
                const start = dayData.start || 'Yopiq';
                const end = dayData.end || 'Yopiq';
                html += `${dayNamesUz[key]}: ${start} - ${end}<br>`;
            });
            infoEl.innerHTML = html;
        }

        /**
         * Determine whether the current time is within business hours based on
         * the schedule retrieved from the server. If no schedule is available
         * for the current day, the function defaults to open. If the current
         * time falls outside the schedule, a closed modal is displayed.
         */
        function checkBusinessHours() {
            const now = new Date();
            const dayIndex = now.getDay(); // 0: Sunday, 6: Saturday
            const dayKeys = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
            const dayKey = dayKeys[dayIndex];

            // Default to open if schedule not specified
            if (!workHours || !workHours[dayKey]) {
                isBusinessHours = true;
                return;
            }
            const { start, end } = workHours[dayKey];
            // If either start or end time is missing, consider closed
            if (!start || !end) {
                isBusinessHours = false;
                populateWorkHoursInfo();
                showClosedModal();
                return;
            }
            // Convert times to minutes since midnight
            const [startH, startM] = start.split(':').map(Number);
            const [endH, endM] = end.split(':').map(Number);
            const startMinutes = startH * 60 + startM;
            const endMinutes = endH * 60 + endM;
            const currentTime = now.getHours() * 60 + now.getMinutes();
            // If end is less than start, the schedule crosses midnight
            if (endMinutes < startMinutes) {
                isBusinessHours = (currentTime >= startMinutes || currentTime <= endMinutes);
            } else {
                isBusinessHours = (currentTime >= startMinutes && currentTime <= endMinutes);
            }
            if (!isBusinessHours) {
                populateWorkHoursInfo();
                showClosedModal();
            }
        }
        
        // Show closed modal
        function showClosedModal() {
            // When showing the closed modal, ensure the schedule section is hidden by default
            if (workHoursInfoEl) {
                workHoursInfoEl.style.display = 'none';
            }
            // Populate the work hours information so it is ready to display
            populateWorkHoursInfo();
            closedModal.style.display = 'block';
        }
        
        // Close closed modal
        closeClosedModalBtn.addEventListener('click', function() {
            closedModal.style.display = 'none';
        });

        // Toggle display of work hours inside the closed modal
        if (showWorkHoursBtn) {
            showWorkHoursBtn.addEventListener('click', function() {
                if (!workHoursInfoEl) return;
                // If the info is hidden, populate and show it
                if (workHoursInfoEl.style.display === 'none' || workHoursInfoEl.style.display === '') {
                    populateWorkHoursInfo();
                    workHoursInfoEl.style.display = 'block';
                } else {
                    // Otherwise hide it
                    workHoursInfoEl.style.display = 'none';
                }
            });
        }

        /**
         * Check whether a specific restaurant is currently open based on the
         * per‑branch schedule loaded from the server.  If no schedule
         * exists for the restaurant it is considered open.  The
         * comparison is performed on the client’s current time and
         * gracefully handles schedules that cross midnight (e.g.
         * 22:00–06:00).  Times are stored in HH:MM format.
         *
         * @param {number|string} restaurantId The ID of the restaurant
         * @returns {boolean} true if the restaurant is open, false otherwise
         */
        function isBranchOpen(restaurantId) {
            if (!branchTimes || !branchTimes[String(restaurantId)]) {
                return true;
            }
            const times = branchTimes[String(restaurantId)];
            if (!times || !times.start || !times.end) {
                return true;
            }
            const now = new Date();
            const [startH, startM] = times.start.split(':').map(Number);
            const [endH, endM] = times.end.split(':').map(Number);
            const startMinutes = startH * 60 + startM;
            const endMinutes = endH * 60 + endM;
            const currentMinutes = now.getHours() * 60 + now.getMinutes();
            if (endMinutes < startMinutes) {
                // Schedule crosses midnight (e.g. 22:00–06:00)
                return (currentMinutes >= startMinutes || currentMinutes <= endMinutes);
            }
            return (currentMinutes >= startMinutes && currentMinutes <= endMinutes);
        }

        /**
         * Show a modal informing the user that the selected restaurant is
         * closed.  Populates the modal content with the restaurant’s
         * name and its configured working hours for today.  If no
         * schedule is available a generic message is displayed.  The
         * modal can be dismissed with a button click.
         *
         * @param {number|string} restaurantId The ID of the restaurant
         */
        function showBranchClosedModal(restaurantId) {
            const modal = document.getElementById('branchClosedModal');
            if (!modal) return;
            const titleEl = document.getElementById('branchClosedTitle');
            const messageEl = document.getElementById('branchClosedMessage');
            const restaurant = restaurants.find(r => r.id === restaurantId);
            const name = restaurant ? restaurant.name : '';
            const times = branchTimes && branchTimes[String(restaurantId)] ? branchTimes[String(restaurantId)] : null;
            if (titleEl) {
                titleEl.textContent = `Hozir ${name}ning ish vaqti tugagan!`;
            }
            if (messageEl) {
                if (times && times.start && times.end) {
                    messageEl.textContent = `Bugungi ish vaqtimiz ${times.start} - ${times.end}`;
                } else {
                    messageEl.textContent = `Bugungi ish vaqtimiz mavjud emas`;
                }
            }
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        // Close handler for the branch closed modal.  When the user
        // acknowledges the message hide the modal and restore page scroll.
        const closeBranchClosedModalBtn = document.getElementById('closeBranchClosedModal');
        if (closeBranchClosedModalBtn) {
            closeBranchClosedModalBtn.addEventListener('click', function() {
                const modal = document.getElementById('branchClosedModal');
                if (modal) modal.style.display = 'none';
                document.body.style.overflow = '';
            });
        }
        
        // Initialize hero slider
        async function initHeroSlider() {
            const sliderEl = document.getElementById('heroSlider');
            if (!sliderEl) return;
            try {
                const response = await fetch(`${API_BASE_URL}/slides`);
                const slidesData = await response.json();
                // Filter out expired slides on client
                const now = new Date();
                const validSlides = slidesData.filter(s => !s.expireAt || new Date(s.expireAt) > now);
                sliderEl.innerHTML = '';
                if (validSlides.length === 0) {
                    // Agar hech qanday slayd yo‘q bo‘lsa, slayderni yashiramiz
                    sliderEl.innerHTML = '';
                    sliderEl.style.display = 'none';
                    return;
                }

                // Build slide elements
                validSlides.forEach(slide => {
                    const div = document.createElement('div');
                    div.className = 'slide';
                    div.style.backgroundImage = `url('${slide.image}')`;
                    sliderEl.appendChild(div);
                });
                const slides = sliderEl.querySelectorAll('.slide');
                let currentSlide = 0;
                if (slides.length > 0) {
                    slides[0].classList.add('active');
                    // If there is more than one slide, start cycling through them every
                    // 4 seconds. When only a single slide exists there is nothing to
                    // cycle through so the interval is omitted. This addresses the
                    // reported issue where multiple slides were not rotating.
                    if (slides.length > 1) {
                        setInterval(() => {
                            slides[currentSlide].classList.remove('active');
                            currentSlide = (currentSlide + 1) % slides.length;
                            slides[currentSlide].classList.add('active');
                        }, 3000);
                    }
                }
            } catch (err) {
                console.error('Failed to initialise hero slider:', err);
            }
        }

        /**
         * Show or hide the hero slider. When rendering search results or favorites
         * the slider should be hidden to give more space to the results. When
         * returning to the home page, it is displayed again. This helper
         * centralises that behaviour.
         * @param {boolean} show
         */
        function showHeroSlider(show) {
            if (heroSlider) {
                heroSlider.style.display = show ? 'block' : 'none';
            }
        }

        /**
         * Load branch types from the API and render them. Branch types classify
         * restaurants into high‑level categories (e.g., Restaurants, Shops). Only
         * active types are shown. Selecting a branch type will filter the
         * restaurant list accordingly. When a new type is selected the
         * selected category is cleared.
         */
        async function loadBranchTypes() {
            try {
                const response = await fetch(`${API_BASE_URL}/branchtypes`);
                if (!response.ok) throw new Error('Failed to fetch branch types');
                branchTypes = await response.json();
                renderBranchTypes();
            } catch (err) {
                console.error('Failed to load branch types:', err);
            }
        }

        /**
         * Render the branch types row. Applies an 'active' class to the
         * currently selected type. Clicking on a type toggles its selection
         * and clears any selected category filter.
         */
        function renderSuggestions(suggestions) {
            const container = document.querySelector('.suggestion-items');
            container.innerHTML = '';

            suggestions.forEach(dish => {
                const item = document.createElement('div');
                item.classList.add('suggestion-item');
                item.setAttribute('data-id', dish.id);
                item.setAttribute('data-name', dish.name);
                item.setAttribute('data-price', dish.price);
                item.setAttribute('data-image', dish.image);
                item.setAttribute('data-desc', dish.description || '');

                item.innerHTML = `
                    <div class="image" style="background-image:url('${dish.image}')"></div>
                    <div class="name">${dish.name}</div>
                    <div class="price">${dish.price} UZS</div>
                `;

                // 🔥 Event qo‘shamiz
                item.addEventListener('click', () => openDishModal(dish));

                container.appendChild(item);
            });
        }

        function renderBranchTypes() {
            if (!branchTypesRow) return;
            branchTypesRow.innerHTML = '';
            // Only show active branch types
            const activeTypes = branchTypes.filter(t => t.active !== false);
            if (activeTypes.length === 0) {
                // If there are no active types, hide the section
                branchTypesRow.style.display = 'none';
                return;
            }
            branchTypesRow.style.display = 'grid';
            activeTypes.forEach(type => {
                const item = document.createElement('div');
                item.className = 'branch-type-item';
                if (selectedBranchTypeId === type.id) {
                    item.classList.add('active');
                }
                // Use provided image or fallback
                const imgSrc = type.image || '/public/images/no-image.jpg';
                item.innerHTML = `
                    <img src="${imgSrc}" alt="${type.name}">
                    <div class="name">${type.name}</div>
                `;
                item.addEventListener('click', function() {
                    // When a branch type is tapped, highlight it and clear any
                    // selected category. Instead of filtering the main page
                    // directly, open a full‑screen modal listing only the
                    // restaurants belonging to this type. The selected
                    // branch type ID is stored so the active state is
                    // visually reflected in the row.
                    selectedBranchTypeId = type.id;
                    selectedCategoryId = null;
                    // Re-render branch types and categories to update active class
                    renderBranchTypes();
                    renderFoodCategories();
                    // Open the filtered restaurants modal
                    openBranchTypeModal(type.id);
                });
                branchTypesRow.appendChild(item);
            });
        }

        /**
         * Load food categories from the API and render them. Categories group
         * dishes (e.g., Fast Food, Drinks). Only active categories are shown.
         */
        async function loadCategories() {
            try {
                const response = await fetch(`${API_BASE_URL}/categories`);
                if (!response.ok) throw new Error('Failed to fetch categories');
                categories = await response.json();
                renderFoodCategories();
            } catch (err) {
                console.error('Failed to load categories:', err);
            }
        }

        /**
         * Render the food categories row. Applies an 'active' class to the
         * currently selected category. Clicking on a category toggles its
         * selection and clears any selected branch type filter.
         */
        function renderFoodCategories() {
            if (!foodCategoriesRow) return;
            foodCategoriesRow.innerHTML = '';
            const activeCategories = categories.filter(c => c.active !== false);
            if (activeCategories.length === 0) {
                foodCategoriesRow.style.display = 'none';
                return;
            }
            // Use flex layout for horizontal scrolling categories instead of grid
            foodCategoriesRow.style.display = 'flex';
            activeCategories.forEach(cat => {
                const item = document.createElement('div');
                item.className = 'food-category-item';
                if (selectedCategoryId === cat.id) {
                    item.classList.add('active');
                }
                const imgSrc = cat.image || '/public/images/no-image.jpg';
                item.innerHTML = `
                    <img src="${imgSrc}" alt="${cat.name}">
                    <div class="name">${cat.name}</div>
                `;
                item.addEventListener('click', function() {
                    // Selecting a category opens a dedicated modal showing only the relevant restaurants.
                    selectedCategoryId = cat.id;
                    selectedBranchTypeId = null;
                    // Re-render to update active state
                    renderFoodCategories();
                    renderBranchTypes();
                    openCategoryModal(cat.id);
                });
                foodCategoriesRow.appendChild(item);
            });
        }

        /**
         * Render the stores (Do'konlar) row. Each store is shown as a square card
         * with its image and name. The row scrolls horizontally when there
         * are more stores than fit on screen. Selecting a store clears any
         * selected filters and opens the restaurant’s dishes.
         */
        function renderStores() {
            if (!storesRow) return;
            storesRow.innerHTML = '';
            // Filter only active restaurants
            const activeStores = restaurants.filter(r => r.active !== false);
            if (activeStores.length === 0) {
                if (storesSection) storesSection.style.display = 'none';
                return;
            }
            if (storesSection) storesSection.style.display = 'block';
            activeStores.forEach(store => {
                const item = document.createElement('div');
                item.className = 'store-item';
                const imgSrc = store.image || '/public/images/no-image.jpg';
                item.innerHTML = `
                    <img src="${imgSrc}" alt="${store.name}">
                    <div class="name">${store.name}</div>
                `;
                item.addEventListener('click', function() {
                    // Reset filters and show this restaurant’s dishes
                    selectedCategoryId = null;
                    selectedBranchTypeId = null;
                    renderFoodCategories();
                    renderBranchTypes();
                    showRestaurantDishes(store.id);
                    try {
                        history.pushState({ modal: 'restaurant', restaurantId: store.id }, '', '');
                    } catch (_) {}
                });
                storesRow.appendChild(item);
            });
        }

        /**
         * Load popular branches and dishes statistics from the API. This
         * endpoint returns the most ordered restaurants and dishes across
         * all time. Only existing restaurants and dishes that are still
         * active will be displayed. Up to six items are shown in each
         * section.
         */
        async function loadPopularData() {
            if (!popularBranchesEl || !popularDishesEl) return;
            try {
                const response = await fetch(`${API_BASE_URL}/public-stats`);
                if (!response.ok) throw new Error('Failed to fetch public stats');
                const data = await response.json();
                const { topRestaurants, topDishes } = data;
                // Map restaurant stats to actual restaurant objects
                const popularRestaurants = [];
                topRestaurants.forEach(stat => {
                    const rest = restaurants.find(r => r.id === stat.restaurant_id && r.active !== false);
                    if (rest) {
                        popularRestaurants.push({ restaurant: rest, count: stat.orders_count });
                    }
                });
                // Do not arbitrarily limit the number of popular branches on the client.
                // The server already ensures that only the top ten percent (or at least
                // three) of all branches are returned via the /api/public-stats
                // endpoint. Rendering the full list here ensures the UI reflects
                // exactly that server-defined selection.  
                renderPopularBranches(popularRestaurants);
                const popularDishesArr = [];
                topDishes.forEach(stat => {
                    const dish = dishes.find(d => d.id === stat.dish_id && d.active !== false);
                    if (dish) {
                        popularDishesArr.push({ dish: dish, count: stat.count });
                    }
                });
                renderPopularDishes(popularDishesArr.slice(0, 6));
            } catch (err) {
                console.error('Failed to load popular data:', err);
            }
        }

        /**
         * Render popular branches into their section. If the list is empty the
         * section is hidden.
         * @param {Array<{restaurant: object, count: number}>} list
         */
        function renderPopularBranches(list) {
            if (!popularBranchesEl || !popularBranchesSection) return;
            popularBranchesEl.innerHTML = '';
            if (!list || list.length === 0) {
                popularBranchesSection.style.display = 'none';
                return;
            }
            popularBranchesSection.style.display = 'block';
            list.forEach(item => {
                const { restaurant, count } = item;
                // Build a simple card for the restaurant. Use first dish image if available.
                const dish = dishes.find(d => d.restaurant_id === restaurant.id && d.active !== false);
                const imgSrc = dish && dish.image ? dish.image : '/public/images/no-image.jpg';
            const card = document.createElement('div');
            card.className = 'restaurant-card';
            card.style.cursor = 'pointer';
            /*
             * Display the branch image prominently at the top of the card,
             * followed by its name and order count. A responsive
             * background image preserves aspect ratio while filling the
             * width of the card. The count is shown in a small caption
             * beneath the name. This layout mimics modern delivery app
             * cards and satisfies the requirement to show both the image
             * and name of each popular branch.
             */
            card.innerHTML = `
                <div style="width:100%;height:0;padding-bottom:75%;background-image:url('${imgSrc}');background-size:cover;background-position:center;border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);"></div>
                <div class="restaurant-name" style="padding:10px 15px 5px;">${restaurant.name}</div>
                <div style="padding:0 15px 10px;font-size:12px;color:var(--gray);">Buyurtmalar soni: ${count}</div>
            `;
                card.addEventListener('click', function() {
                    // Scroll to restaurant in main list by simulating a click on its name
                    const restElement = document.querySelector(`[id='dishes-${restaurant.id}']`);
                    if (restElement) {
                        restElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
                popularBranchesEl.appendChild(card);
            });
        }

        /**
         * Render popular dishes into their section. If the list is empty the
         * section is hidden.
         * @param {Array<{dish: object, count: number}>} list
         */
        function renderPopularDishes(list) {
            if (!popularDishesEl || !popularDishesSection) return;
            popularDishesEl.innerHTML = '';
            if (!list || list.length === 0) {
                popularDishesSection.style.display = 'none';
                return;
            }
            popularDishesSection.style.display = 'block';
            list.forEach(item => {
                const { dish, count } = item;
                const card = document.createElement('div');
                card.className = 'dish-card';
                card.dataset.id = dish.id;
                card.innerHTML = `
                    <div class="dish-image" style="background-image: url('${dish.image || '/public/images/no-image.jpg'}')"></div>
                    <div class="dish-info">
                        <div class="dish-name">${dish.name}</div>
                        <div class="dish-price">${dish.price ? dish.price.toLocaleString() + ' UZS' : ''}</div>
                    </div>
                `;
                card.addEventListener('click', function() {
                    openDishModal(dish.id);
                });
                popularDishesEl.appendChild(card);
            });
        }
        
        // Load initial data from API
        async function loadInitialData() {
            try {
                // Load restaurants
                const restaurantsResponse = await fetch(`${API_BASE_URL}/restaurants`);
                restaurants = await restaurantsResponse.json();
                
                // Load dishes
                const dishesResponse = await fetch(`${API_BASE_URL}/dishes`);
                dishes = await dishesResponse.json();
                
                // Load containers
                const containersResponse = await fetch(`${API_BASE_URL}/containers`);
                containers = await containersResponse.json();
                
                // Load promocodes
                const promocodesResponse = await fetch(`${API_BASE_URL}/promocodes`);
                promocodes = await promocodesResponse.json();
                
                // Load per‑branch opening hours before rendering restaurants.  The
                // response is a mapping of restaurant IDs to simple start/end
                // times.  If the request fails the variable will remain an
                // empty object and all branches will be considered open.
                try {
                    const branchTimesResponse = await fetch(`${API_BASE_URL}/branchtimes`);
                    branchTimes = await branchTimesResponse.json();
                } catch (err) {
                    console.error('Failed to load branch times:', err);
                    branchTimes = {};
                }

                // Render restaurants and dishes
                renderRestaurants();

                // After loading core data, load branch types, categories and popular stats
                await loadBranchTypes();
                await loadCategories();
                // Render stores (restaurants) list after categories have been loaded
                renderStores();
                await loadPopularData();

                // Build a context string for the Kago agent once the core data
                // (restaurants, dishes, branch types and work hours) has been
                // loaded. This context is sent to the AI so it can answer
                // questions based on the current state of the site. See
                // buildAgentContext() below for details.
                if (typeof buildAgentContext === 'function') {
                    try {
                        buildAgentContext();
                    } catch (_) {}
                }
            } catch (error) {
                console.error('Failed to load initial data:', error);
            }
        }
        
        // Render restaurants and dishes
        function renderRestaurants(filter = '') {
            restaurantsList.innerHTML = '';
            
            // Start from all active restaurants
            let filteredRestaurants = restaurants.filter(r => r.active !== false);

            // Apply search filter if provided
            if (filter) {
                const lower = filter.toLowerCase();
                filteredRestaurants = filteredRestaurants.filter(r => r.name.toLowerCase().includes(lower));
            }

            // Apply branch type filter if selected
            if (selectedBranchTypeId) {
                filteredRestaurants = filteredRestaurants.filter(r => r.branchTypeId === selectedBranchTypeId);
            }

            // Apply category filter if selected: show restaurants that have at least
            // one active dish belonging to the selected category.
            if (selectedCategoryId) {
                filteredRestaurants = filteredRestaurants.filter(r => {
                    return dishes.some(d => d.restaurant_id === r.id && d.category_id === selectedCategoryId && (d.active !== false));
                });
            }

            // Filter out restaurants that are currently closed.  The
            // isBranchOpen() helper returns true for any branch without
            // explicit times and correctly handles schedules that cross
            // midnight.  This ensures that closed branches are hidden
            // only in the Filiallar section; they still appear in other
            // areas of the site but attempting to open them will show
            // a closed modal.
            filteredRestaurants = filteredRestaurants.filter(r => isBranchOpen(r.id));
            
            if (filteredRestaurants.length === 0) {
                restaurantsList.innerHTML = '<p style="text-align: center; padding: 20px;">Doʻkonlar topilmadi</p>';
                return;
            }
            
            let listToRender;
            if (!filter) {
                // No search filter: maintain a consistent random order across renders
                if (!shuffledRestaurantsOrder || shuffledRestaurantsOrder.length !== filteredRestaurants.length) {
                    shuffledRestaurantsOrder = filteredRestaurants.map(r => r.id).sort(() => Math.random() - 0.5);
                }
                listToRender = shuffledRestaurantsOrder.map(id => filteredRestaurants.find(r => r.id === id)).filter(Boolean);
            } else {
                // When filtering (search), do not use the stored order; just use filtered list
                listToRender = filteredRestaurants;
            }
            listToRender.forEach(restaurant => {
                // Filter dishes for this restaurant
                const restaurantDishes = dishes.filter(dish => dish.restaurant_id === restaurant.id && (dish.active !== false));
                if (restaurantDishes.length === 0) return;
                const restaurantElement = document.createElement('div');
                restaurantElement.className = 'restaurant-card';
                // Display the number of dishes next to the restaurant name with
                // an arrow. For example, "Alfa 35>" if there are 35 dishes.
                const dishCount = restaurantDishes.length;
                const countLabel = dishCount > 0 ? `<span class="more-count">(${dishCount} ta mahsulot)</span>` : '';
                restaurantElement.innerHTML = `
                    <div class="restaurant-name">${restaurant.name}${countLabel}</div>
                    <div class="dishes-container" id="dishes-${restaurant.id}">
                        <!-- Dishes will be loaded here -->
                    </div>
                `;
                restaurantsList.appendChild(restaurantElement);
                // Render dishes for this restaurant
                const dishesContainer = document.getElementById(`dishes-${restaurant.id}`);
                // Add horizontal slider class
                dishesContainer.classList.add('restaurant-dishes');
                renderDishes(restaurantDishes, dishesContainer);
                // When the restaurant name is clicked, show only that restaurant's dishes in the modal
                const nameEl = restaurantElement.querySelector('.restaurant-name');
                if (nameEl) {
                    nameEl.style.cursor = 'pointer';
                    nameEl.addEventListener('click', function() {
                        showRestaurantDishes(restaurant.id);
                        try {
                            history.pushState({ modal: 'restaurant', restaurantId: restaurant.id }, '', '');
                        } catch (_) {}
                    });
                }
            });
        }
        
        // Render dishes for a restaurant
        function renderDishes(dishesList, container) {
            container.innerHTML = '';
            
            // Filter out inactive dishes and randomise their order
            const activeDishes = dishesList.filter(d => d.active !== false);
            if (activeDishes.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 20px;">Mahsulotlar topilmadi</p>';
                return;
            }
            const shuffled = [...activeDishes].sort(() => Math.random() - 0.5);
            shuffled.forEach(dish => {
                const isFavorite = favorites.some(fav => fav.id === dish.id);
                const dishElement = document.createElement('div');
                dishElement.className = 'dish-card';
                dishElement.dataset.id = dish.id;
                dishElement.innerHTML = `
                    <div class="dish-favorite ${isFavorite ? 'active' : ''}" data-id="${dish.id}">
                        <i class="${isFavorite ? 'fas' : 'far'} fa-heart"></i>
                    </div>
                    <div class="dish-image" style="background-image: url('${dish.image || '/public/images/no-image.jpg'}')"></div>
                    <div class="dish-info">
                        <div class="dish-name">${dish.name}</div>
                        <div class="dish-price">${dish.price ? dish.price.toLocaleString() + ' UZS' : ''}</div>
                    </div>
                `;
                container.appendChild(dishElement);
                // Open dish modal on click
                dishElement.addEventListener('click', function() {
                    openDishModal(dish.id);
                });
                // Toggle favourite state
                const favoriteBtn = dishElement.querySelector('.dish-favorite');
                favoriteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleFavorite(dish);
                });
            });
        }
        
        searchInput.addEventListener('input', function() {
            const searchTerm = this.value.trim().toLowerCase();

            if (!searchTerm) {
                // Standard state: show all restaurants and dishes and restore hero slider
                showHeroSlider(true);
                // Restore section visibility when search is cleared
                if (branchTypesSection) branchTypesSection.style.display = '';
                if (foodCategoriesSection) foodCategoriesSection.style.display = '';
                if (popularBranchesSection) popularBranchesSection.style.display = '';
                if (popularDishesSection) popularDishesSection.style.display = '';
                renderRestaurants();
                return;
            }

            // Hide hero slider when searching
            showHeroSlider(false);

            // Hide non‑search sections during search
            if (branchTypesSection) branchTypesSection.style.display = 'none';
            if (foodCategoriesSection) foodCategoriesSection.style.display = 'none';
            if (popularBranchesSection) popularBranchesSection.style.display = 'none';
            if (popularDishesSection) popularDishesSection.style.display = 'none';

            // Faqat mahsulotlar bo‘yicha global qidiruv
            const foundDishes = dishes.filter(dish =>
                dish.name.toLowerCase().includes(searchTerm)
            );

            // Ekranni tozalash
            restaurantsList.innerHTML = '';

            if (foundDishes.length === 0) {
                restaurantsList.innerHTML = '<p style="text-align: center; padding: 20px;">Hechnima topilmadi</p>';
                return;
            }

            // Topilgan har bir mahsulot uchun uning restorani va mahsulot kartasini chiqarish
            foundDishes.forEach(dish => {
                const restaurant = restaurants.find(r => r.id === dish.restaurant_id);

                // Bitta kartochka ichida doʻkonnomi va mahsulot ma’lumotlari
                const searchDishCard = document.createElement('div');
                searchDishCard.className = 'restaurant-card';
                searchDishCard.innerHTML = `
                    <div class="restaurant-name">${restaurant ? restaurant.name : 'Doʻkon topilmadi'}</div>
                    <div class="dishes-container">
                        <div class="dish-card" data-id="${dish.id}">
                            <div class="dish-favorite ${favorites.some(fav => fav.id === dish.id) ? 'active' : ''}" data-id="${dish.id}">
                                <i class="fas fa-heart"></i>
                            </div>
                            <div class="dish-image" style="background-image: url('${dish.image || '/public/images/no-image.jpg'}')"></div>
                            <div class="dish-info">
                                <div class="dish-name">${dish.name}</div>
                                <div class="dish-price">${dish.price ? dish.price.toLocaleString() + ' UZS' : ''}</div>
                            </div>
                        </div>
                    </div>
                `;
                restaurantsList.appendChild(searchDishCard);

                // Modal ochish uchun event
                searchDishCard.querySelector('.dish-card').addEventListener('click', function() {
                    openDishModal(dish.id);
                });

                // Favorite uchun event
                searchDishCard.querySelector('.dish-favorite').addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleFavorite(dish);
                });
            });
        });

        // Open dish modal
        async function openDishModal(dishId) {
            try {
                // Find the dish
                const dish = dishes.find(d => d.id === dishId);
                if (!dish) return;
                
                currentDish = dish;
                selectedVariant = null;
                selectedContainer = null;
                
                // Set dish info
                modalDishImage.style.backgroundImage = `url('${dish.image || '/public/images/no-image.jpg'}')`;
                modalDishName.textContent = dish.name;
                modalDishPrice.textContent = dish.price ? dish.price.toLocaleString() + ' UZS' : '';
                modalDishDesc.textContent = dish.desc || 'Tavsif mavjud emas';
                
                // Reset variant and container containers and hide them initially
                variantsContainer.innerHTML = '';
                variantsContainer.style.display = 'none';
                containersContainer.innerHTML = '';
                containersContainer.style.display = 'none';
                // Reset global flag for available containers
                availableContainerCount = 0;
                selectedContainer = null;

                // If dish has variants, render them with a heading
                if (dish.variants && dish.variants.length > 0) {
                    variantsContainer.style.display = 'block';
                    const vTitle = document.createElement('div');
                    vTitle.className = 'variant-title';
                    vTitle.textContent = 'Variantlar';
                    variantsContainer.appendChild(vTitle);
                    // Shuffle variants for randomness
                    const variantsList = [...dish.variants].sort(() => Math.random() - 0.5);
                    variantsList.forEach((variant, index) => {
                        const variantElement = document.createElement('div');
                        variantElement.className = 'variant-item';
                        variantElement.innerHTML = `
                            <div class="variant-info">
                                <div class="variant-name">${variant.name}</div>
                                <div class="variant-price">${variant.price.toLocaleString()} UZS</div>
                            </div>
                            <div class="variant-quantity">
                                <button class="quantity-btn minus" data-index="${index}">-</button>
                                <input type="text" class="quantity-input" value="1" readonly>
                                <button class="quantity-btn plus" data-index="${index}">+</button>
                            </div>
                        `;
                        variantsContainer.appendChild(variantElement);
                        // Set first variant as selected by default
                        if (index === 0) {
                            variantElement.style.borderColor = 'var(--primary)';
                            variantElement.style.backgroundColor = 'rgba(74, 107, 255, 0.05)';
                            selectedVariant = {
                                ...variant,
                                quantity: 1
                            };
                            updateDishTotalPrice();
                        }
                        // Click event to select variant
                        variantElement.addEventListener('click', function() {
                            document.querySelectorAll('.variant-item').forEach(item => {
                                item.style.borderColor = 'var(--light-gray)';
                                item.style.backgroundColor = 'transparent';
                            });
                            this.style.borderColor = 'var(--primary)';
                            this.style.backgroundColor = 'rgba(74, 107, 255, 0.05)';
                            const quantity = parseInt(this.querySelector('.quantity-input').value);
                            selectedVariant = {
                                ...variant,
                                quantity: quantity
                            };
                            updateDishTotalPrice();
                        });
                        // Quantity button events
                        const minusBtn = variantElement.querySelector('.minus');
                        const plusBtn = variantElement.querySelector('.plus');
                        const quantityInput = variantElement.querySelector('.quantity-input');
                        minusBtn.addEventListener('click', function(e) {
                            e.stopPropagation();
                            let value = parseInt(quantityInput.value);
                            if (value > 1) {
                                value--;
                                quantityInput.value = value;
                                if (selectedVariant && selectedVariant.name === variant.name) {
                                    selectedVariant.quantity = value;
                                    updateDishTotalPrice();
                                }
                            }
                        });
                        plusBtn.addEventListener('click', function(e) {
                            e.stopPropagation();
                            let value = parseInt(quantityInput.value);
                            value++;
                            quantityInput.value = value;
                            if (selectedVariant && selectedVariant.name === variant.name) {
                                selectedVariant.quantity = value;
                                updateDishTotalPrice();
                            }
                        });
                    });
                } else {
                    // If no variants, treat the dish itself as a variant and allow quantity selection
                    selectedVariant = {
                        id: dish.id,
                        name: dish.name,
                        price: dish.price,
                        image: dish.image,
                        quantity: 1
                    };
                    // Display a simple quantity selector for plain dishes
                    variantsContainer.style.display = 'block';
                    const qtyWrapper = document.createElement('div');
                    qtyWrapper.className = 'variant-quantity';
                    qtyWrapper.innerHTML = `
                        <button class="quantity-btn minus">-</button>
                        <input type="text" class="quantity-input" value="1" readonly>
                        <button class="quantity-btn plus">+</button>
                    `;
                    variantsContainer.appendChild(qtyWrapper);
                    const qMinus = qtyWrapper.querySelector('.minus');
                    const qPlus = qtyWrapper.querySelector('.plus');
                    const qInput = qtyWrapper.querySelector('.quantity-input');
                    qMinus.addEventListener('click', function(e) {
                        e.stopPropagation();
                        let value = parseInt(qInput.value);
                        if (value > 1) {
                            value--;
                            qInput.value = value;
                            selectedVariant.quantity = value;
                            updateDishTotalPrice();
                        }
                    });
                    qPlus.addEventListener('click', function(e) {
                        e.stopPropagation();
                        let value = parseInt(qInput.value);
                        value++;
                        qInput.value = value;
                        selectedVariant.quantity = value;
                        updateDishTotalPrice();
                    });
                    updateDishTotalPrice();
                }
                // Prepare active containers list
                const activeContainersList = [];
                if (dish.containers && dish.containers.length > 0) {
                    dish.containers.forEach(containerId => {
                        const container = containers.find(c => c.id === containerId && c.active !== false);
                        if (container) {
                            activeContainersList.push(container);
                        }
                    });
                }
                availableContainerCount = activeContainersList.length;
                if (availableContainerCount > 0) {
                    containersContainer.style.display = 'block';
                    // Add title
                    const cTitle = document.createElement('div');
                    cTitle.className = 'container-title';
                    cTitle.textContent = 'Idishlar';
                    containersContainer.appendChild(cTitle);
                    activeContainersList.forEach((container, idx) => {
                        const containerElement = document.createElement('div');
                        containerElement.className = 'container-item';
                        containerElement.dataset.id = container.id;
                        containerElement.innerHTML = `
                            <div class="container-info">
                                <div class="container-name">${container.name}</div>
                                <div class="container-price">${container.price.toLocaleString()} UZS</div>
                            </div>
                            <div class="variant-quantity">
                                <button class="quantity-btn minus" data-container-id="${container.id}">-</button>
                                <input type="text" class="quantity-input" value="1" readonly>
                                <button class="quantity-btn plus" data-container-id="${container.id}">+</button>
                            </div>
                            <div class="container-radio"></div>
                        `;
                        containersContainer.appendChild(containerElement);
                        // Do not pre-select any container by default; user must choose one if available
                        // Select container on click
                        containerElement.addEventListener('click', function() {
                            document.querySelectorAll('.container-item').forEach(item => item.classList.remove('selected'));
                            this.classList.add('selected');
                            const qty = parseInt(this.querySelector('.quantity-input').value);
                            selectedContainer = {
                                ...container,
                                quantity: qty
                            };
                            updateDishTotalPrice();
                        });
                        // Quantity control events for containers
                        const cMinus = containerElement.querySelector('.minus');
                        const cPlus = containerElement.querySelector('.plus');
                        const cInput = containerElement.querySelector('.quantity-input');
                        cMinus.addEventListener('click', function(e) {
                            e.stopPropagation();
                            let v = parseInt(cInput.value);
                            if (v > 1) {
                                v--;
                                cInput.value = v;
                                if (selectedContainer && selectedContainer.id === container.id) {
                                    selectedContainer.quantity = v;
                                    updateDishTotalPrice();
                                }
                            }
                        });
                        cPlus.addEventListener('click', function(e) {
                            e.stopPropagation();
                            let v = parseInt(cInput.value);
                            v++;
                            cInput.value = v;
                            if (selectedContainer && selectedContainer.id === container.id) {
                                selectedContainer.quantity = v;
                                updateDishTotalPrice();
                            }
                        });
                    });
                } else {
                    // No containers available for this dish
                    selectedContainer = null;
                }
                
                // Open modal
                dishModal.style.display = 'block';
                // Hide hero slider while a dish modal is open
                showHeroSlider(false);
                // Push a new history state so that the back button closes the modal rather than leaving the page
                try {
                    history.pushState({ modal: 'dish', dishId: dish.id }, '', '');
                } catch (_) {}
            } catch (error) {
                console.error('Failed to open dish modal:', error);
            }
        }
        
        // Close dish modal
        closeDishModalBtn.addEventListener('click', function() {
            // Hide the dish modal
            dishModal.style.display = 'none';
            // Re-enable page scrolling
            document.body.style.overflow = '';
            // Show the hero slider again
            showHeroSlider(true);
            // Do not navigate browser history when closing the modal
        });
        
        // Update dish total price in modal
        function updateDishTotalPrice() {
            if (!selectedVariant) return;
            
            let total = selectedVariant.price * selectedVariant.quantity;
            
            if (selectedContainer) {
                // When a container is selected, its price should only depend on its own quantity.
                // Do NOT multiply container cost by the number of food portions.
                total += selectedContainer.price * (selectedContainer.quantity || 1);
            }
            
            dishTotalPrice.textContent = total.toLocaleString() + ' UZS';
        }
        
        // Add to cart
        addToCartBtn.addEventListener('click', function() {
            if (!currentDish || !selectedVariant) return;
            
            // If active containers are available for this dish, require selection
            if (availableContainerCount > 0 && !selectedContainer) {
                alert('Iltimos, mahsulotni yetkazib berishimiz uchun kerakli idishdan yetarli miqdorda tanlang!');
                return;
            }
            
            // Create cart item
            const cartItem = {
                dishId: currentDish.id,
                restaurantId: currentDish.restaurant_id,
                name: currentDish.name,
                variant: {
                    name: selectedVariant.name,
                    price: selectedVariant.price
                },
                quantity: selectedVariant.quantity,
                container: selectedContainer ? {
                    id: selectedContainer.id,
                    name: selectedContainer.name,
                    price: selectedContainer.price,
                    quantity: selectedContainer.quantity || 1
                } : null,
                image: currentDish.image
            };
            
            // Add to cart
            cart.push(cartItem);
            
            // Save to localStorage
            localStorage.setItem('cart', JSON.stringify(cart));
            
            // Update cart count
            updateCartCount();
            
            // Close modal
            dishModal.style.display = 'none';
            
            // Show success message
            alert('Savatga qo\'shildi!');
        });
        
        // Toggle favorite
        function toggleFavorite(dish) {
            const index = favorites.findIndex(fav => fav.id === dish.id);
            
            if (index === -1) {
                // Add to favorites
                favorites.push({
                    id: dish.id,
                    name: dish.name,
                    price: dish.price,
                    image: dish.image,
                    restaurantId: dish.restaurant_id
                });
            } else {
                // Remove from favorites
                favorites.splice(index, 1);
            }
            
            // Save to localStorage
            localStorage.setItem('favorites', JSON.stringify(favorites));
            
            // Update UI
            const favoriteBtn = document.querySelector(`.dish-favorite[data-id="${dish.id}"]`);
            if (favoriteBtn) {
                // Toggle the active class
                favoriteBtn.classList.toggle('active');
                const iconEl = favoriteBtn.querySelector('i');
                // If the dish is now in favorites, use solid heart; otherwise outline
                const exists = favorites.some(fav => fav.id === dish.id);
                if (iconEl) {
                    if (exists) {
                        iconEl.classList.remove('far');
                        iconEl.classList.add('fas');
                    } else {
                        iconEl.classList.remove('fas');
                        iconEl.classList.add('far');
                    }
                }
            }
        }
        
        // Render only favorite dishes. This function clears the restaurant list
        // and displays a grid of favorite dishes. If no favorites exist, a message
        // is displayed.
        function renderFavorites() {
            // Clear the current view
            restaurantsList.innerHTML = '';
            // If there are no favorites
            if (!favorites || favorites.length === 0) {
                restaurantsList.innerHTML = '<p style="text-align: center; padding: 20px;">Sevimli mahsulotlar mavjud emas</p>';
                return;
            }
            // Create a container for favorite dishes
            const favContainer = document.createElement('div');
            favContainer.className = 'dishes-container';
            favorites.forEach(fav => {
                // Find the full dish object to get current info (name, price, image)
                const dish = dishes.find(d => d.id === fav.id);
                if (!dish || dish.active === false) return;
                const isFav = true;
                const dishElement = document.createElement('div');
                dishElement.className = 'dish-card';
                dishElement.dataset.id = dish.id;
                dishElement.innerHTML = `
                    <div class="dish-favorite ${isFav ? 'active' : ''}" data-id="${dish.id}">
                        <i class="${isFav ? 'fas' : 'far'} fa-heart"></i>
                    </div>
                    <div class="dish-image" style="background-image: url('${dish.image || '/public/images/no-image.jpg'}')"></div>
                    <div class="dish-info">
                        <div class="dish-name">${dish.name}</div>
                        <div class="dish-price">${dish.price ? dish.price.toLocaleString() + ' UZS' : ''}</div>
                    </div>
                `;
                // Click on dish opens modal
                dishElement.addEventListener('click', function() {
                    openDishModal(dish.id);
                });
                // Clicking heart toggles favorite state
                const favBtn = dishElement.querySelector('.dish-favorite');
                favBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleFavorite(dish);
                    // Re-render favorites list to reflect change
                    renderFavorites();
                });
                favContainer.appendChild(dishElement);
            });
            restaurantsList.appendChild(favContainer);
        }

        // Add click handlers for favorites buttons
        if (favoritesBtn) {
            favoritesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                // Hide hero slider and non‑favorites sections, then render favorites
                showHeroSlider(false);
                // Hide category and branch sections so only the favorites grid is visible
                if (branchTypesSection) branchTypesSection.style.display = 'none';
                if (foodCategoriesSection) foodCategoriesSection.style.display = 'none';
                if (popularBranchesSection) popularBranchesSection.style.display = 'none';
                if (popularDishesSection) popularDishesSection.style.display = 'none';
                try {
                    history.pushState({ page: 'favorites' }, '', '');
                } catch (_) {}
                renderFavorites();
                // Highlight nav item if exists
                document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
                if (favoritesNavBtn) favoritesNavBtn.classList.add('active');
            });
        }
        if (favoritesNavBtn) {
            favoritesNavBtn.addEventListener('click', function(e) {
                e.preventDefault();
                // Highlight the selected nav item
                document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
                this.classList.add('active');
                // Hide hero slider and non‑favorites sections, then render favorites
                showHeroSlider(false);
                if (branchTypesSection) branchTypesSection.style.display = 'none';
                if (foodCategoriesSection) foodCategoriesSection.style.display = 'none';
                if (popularBranchesSection) popularBranchesSection.style.display = 'none';
                if (popularDishesSection) popularDishesSection.style.display = 'none';
                // Push state so back button returns to previous view
                try {
                    history.pushState({ page: 'favorites' }, '', '');
                } catch (_) {}
                renderFavorites();
            });
        }

        // Doʻkonlar modalini ochish
        document.querySelector('.nav-item:nth-child(2)').addEventListener('click', function(e) {
            e.preventDefault();
            openRestaurantsModal();
        });

        // Bosh sahifa tugmasi: barcha doʻkonlarni qayta ko'rsatish
        const homeNavBtn = document.querySelector('.bottom-nav .nav-item:nth-child(1)');
        if (homeNavBtn) {
            homeNavBtn.addEventListener('click', function(e) {
                e.preventDefault();
                // Highlight home nav item
                document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
                this.classList.add('active');
                // Show hero slider and restore all category/branch sections then render restaurants
                showHeroSlider(true);
                if (branchTypesSection) branchTypesSection.style.display = '';
                if (foodCategoriesSection) foodCategoriesSection.style.display = '';
                if (popularBranchesSection) popularBranchesSection.style.display = '';
                if (popularDishesSection) popularDishesSection.style.display = '';
                // Re-render branch types and categories in case they were hidden
                renderBranchTypes();
                renderFoodCategories();
                renderRestaurants();
                // Push state for home page
                try {
                    history.pushState({ page: 'home' }, '', '');
                } catch (_) {}
            });
        }

        // Doʻkonlar modalini yopish
        document.getElementById('closeRestaurantsModal').addEventListener('click', function() {
            const restModalEl = document.getElementById('restaurantsModal');
            if (restModalEl) restModalEl.style.display = 'none';
            // Reset the modal header title back to the default
            const defaultHeader = document.querySelector('#restaurantsModal .modal-header h2');
            if (defaultHeader) {
                defaultHeader.textContent = 'Doʻkonlar';
            }
            // Clear any selected branch type or category so the main page
            // returns to its default state when the modal is closed
            selectedBranchTypeId = null;
            selectedCategoryId = null;
            renderBranchTypes();
            renderFoodCategories();
            renderRestaurants();
            // Re-enable body scrolling and restore hero slider
            document.body.style.overflow = '';
            showHeroSlider(true);
            // Highlight the home navigation item
            document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
            const homeBtn = document.querySelector('.bottom-nav .nav-item:nth-child(1)');
            if (homeBtn) homeBtn.classList.add('active');
            // Do not navigate browser history when closing the restaurants modal
        });

        // Doʻkonlar modalini ochish funksiyasi
        function openRestaurantsModal() {
            const modalContent = document.getElementById('restaurantsModalContent');
            modalContent.innerHTML = '';
            // Prevent the page underneath from scrolling while the modal is open
            document.body.style.overflow = 'hidden';
            // Build a grid container for restaurants
            const grid = document.createElement('div');
            grid.className = 'restaurant-grid';
            // Only show active restaurants in the modal
            restaurants.filter(r => r.active !== false).forEach(restaurant => {
                const item = document.createElement('div');
                item.className = 'restaurant-grid-item';
                item.innerHTML = `
                    <img src="${restaurant.image || '/public/images/no-image.jpg'}" alt="${restaurant.name}">
                    <div class="name">${restaurant.name}</div>
                `;
                item.addEventListener('click', function() {
                    showRestaurantDishes(restaurant.id);
                });
                grid.appendChild(item);
            });
            modalContent.appendChild(grid);
            // Display the modal
            document.getElementById('restaurantsModal').style.display = 'block';
            // Hide hero slider while viewing restaurants list
            showHeroSlider(false);
            // Highlight restaurants navigation item
            document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
            const navItem = document.querySelector('.bottom-nav .nav-item:nth-child(2)');
            if (navItem) navItem.classList.add('active');
            // Push state for restaurants modal
            try {
                history.pushState({ modal: 'restaurants' }, '', '');
            } catch (_) {}
        }

        /**
         * Open the restaurants modal filtered by a specific branch type. This
         * helper is invoked when a user taps on a branch type tile in the
         * home page. It reuses the existing restaurants modal, updates
         * the header to the selected type’s name, and populates the modal
         * with only those restaurants whose `branchTypeId` matches the
         * provided id. Tapping a restaurant opens its dishes in the same
         * way as the generic modal. A history state is pushed so that
         * pressing the browser’s back button closes the modal instead of
         * navigating away from the site.
         * @param {number} typeId The ID of the branch type to filter by
         */
        function openBranchTypeModal(typeId) {
            // Lookup the branch type for the header title
            const typeObj = branchTypes.find(t => t.id === typeId);
            const modalHeader = document.querySelector('#restaurantsModal .modal-header h2');
            if (modalHeader) {
                modalHeader.textContent = typeObj ? typeObj.name : 'Doʻkonlar';
            }
            const modalContent = document.getElementById('restaurantsModalContent');
            modalContent.innerHTML = '';
            // Prevent the page underneath from scrolling while the modal is open
            document.body.style.overflow = 'hidden';
            // Build a grid container for restaurants of the selected type
            const grid = document.createElement('div');
            grid.className = 'restaurant-grid';
            restaurants
                .filter(r => r.active !== false && r.branchTypeId === typeId)
                .forEach(restaurant => {
                    const item = document.createElement('div');
                    item.className = 'restaurant-grid-item';
                    item.innerHTML = `
                        <img src="${restaurant.image || '/public/images/no-image.jpg'}" alt="${restaurant.name}">
                        <div class="name">${restaurant.name}</div>
                    `;
                    item.addEventListener('click', function() {
                        showRestaurantDishes(restaurant.id);
                    });
                    grid.appendChild(item);
                });
            modalContent.appendChild(grid);
            // Display the modal
            document.getElementById('restaurantsModal').style.display = 'block';
            // Hide hero slider while viewing the list
            showHeroSlider(false);
            // Remove nav selection
            document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
            // Push history state to handle back button
            try {
                history.pushState({ modal: 'branch-type', typeId: typeId }, '', '');
            } catch (_) {}
        }

        /**
         * Open a modal listing only those restaurants that have dishes belonging
         * to the selected category. This mirrors the behaviour of opening a branch
         * type modal but filters based on dish.category_id instead of branchTypeId.
         * @param {number} categoryId The ID of the category to filter by
         */
        function openCategoryModal(categoryId) {
            // Lookup the category for the header title
            const catObj = categories.find(c => c.id === categoryId);
            const modalHeader = document.querySelector('#restaurantsModal .modal-header h2');
            if (modalHeader) {
                modalHeader.textContent = catObj ? catObj.name : 'Filiallar';
            }
            const modalContent = document.getElementById('restaurantsModalContent');
            modalContent.innerHTML = '';
            // Prevent the page underneath from scrolling while the modal is open
            document.body.style.overflow = 'hidden';
            // Build a grid container for restaurants that offer at least one dish from this category
            const grid = document.createElement('div');
            grid.className = 'restaurant-grid';
            restaurants
                .filter(r => r.active !== false)
                .forEach(restaurant => {
                    // Determine if the restaurant has any active dish in the selected category
                    const hasCategoryDish = dishes.some(dish => {
                        return dish.restaurant_id === restaurant.id && dish.category_id === categoryId;
                    });
                    if (hasCategoryDish) {
                        const item = document.createElement('div');
                        item.className = 'restaurant-grid-item';
                        item.innerHTML = `
                            <img src="${restaurant.image || '/public/images/no-image.jpg'}" alt="${restaurant.name}">
                            <div class="name">${restaurant.name}</div>
                        `;
                        item.addEventListener('click', function() {
                            showRestaurantDishes(restaurant.id);
                        });
                        grid.appendChild(item);
                    }
                });
            // If no restaurants offer this category, display a friendly message
            if (grid.children.length === 0) {
                const msg = document.createElement('div');
                msg.style.padding = '20px';
                msg.style.textAlign = 'center';
                msg.style.color = 'var(--gray)';
                msg.textContent = 'Bu turdagi mahsulotlarni taklif qiladigan filiallar topilmadi.';
                modalContent.appendChild(msg);
            } else {
                modalContent.appendChild(grid);
            }
            // Display the modal
            document.getElementById('restaurantsModal').style.display = 'block';
            // Hide hero slider while viewing the list
            showHeroSlider(false);
            // Remove nav selection
            document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
            // Push history state to handle back button
            try {
                history.pushState({ modal: 'category', categoryId: categoryId }, '', '');
            } catch (_) {}
        }

        // Doʻkonmahsulotlarini ko'rsatish funksiyasi
        // Doʻkon mahsulotlarini ko'rsatish funksiyasi
        function showRestaurantDishes(restaurantId) {
        const restaurant = restaurants.find(r => r.id === restaurantId);

        // If the branch is closed according to the per‑branch schedule,
        // display a message instead of opening the menu.  This check
        // ensures that branch‑level working hours take precedence over
        // other interactions throughout the site.
        if (!isBranchOpen(restaurantId)) {
            showBranchClosedModal(restaurantId);
            return;
        }

        const restaurantDishes = dishes.filter(dish => dish.restaurant_id === restaurantId);

        const modalContent = document.getElementById('restaurantsModalContent');
        modalContent.innerHTML = `
            <div class="single-restaurant-header">
            <div class="single-restaurant-back" id="backToRestaurantsList">
                <i class="fas fa-store"></i>
            </div>
            <h2>${restaurant.name}</h2>
            </div>
            <div class="dishes-container" id="restaurantDishesContainer"></div>
        `;

        /* >>> YANGI QO‘SHILGAN QATORLAR — modalni ko‘rsatish va scrollni bloklash */
        const restaurantsModalEl = document.getElementById('restaurantsModal');
        if (restaurantsModalEl) {
            restaurantsModalEl.style.display = 'block';   // modalni ochamiz
        }
        document.body.style.overflow = 'hidden';        // orqa fon scroll bo‘lmasin

        // tugma
        document.getElementById('backToRestaurantsList').addEventListener('click', function() {
            openRestaurantsModal();
        });

        // Mahsulotlarni chizish
        const dishesContainer = document.getElementById('restaurantDishesContainer');
        renderDishes(restaurantDishes, dishesContainer);

        showHeroSlider(false);
        }

        // Open cart modal: prevent default link behaviour and show the cart
        if (cartBtn) {
            cartBtn.addEventListener('click', function(e) {
                e.preventDefault();
                openCartModal();
            });
        }
        if (cartNavBtn) {
            cartNavBtn.addEventListener('click', function(e) {
                e.preventDefault();
                openCartModal();
            });
        }
        
        function openCartModal() {
            renderCartItems();
            // Hide hero slider while viewing cart
            showHeroSlider(false);
            // Prevent page from scrolling underneath the cart sheet
            document.body.style.overflow = 'hidden';
            // Show the cart modal
            cartModal.style.display = 'block';
            // Push history state so that back button closes the cart instead of leaving the app
            try {
                history.pushState({ modal: 'cart' }, '', '');
            } catch (_) {}
        }
        
        // Close cart modal
        closeCartModalBtn.addEventListener('click', function() {
            // Hide the cart modal
            cartModal.style.display = 'none';
            // Re-enable page scrolling
            document.body.style.overflow = '';
            // Show the hero slider again
            showHeroSlider(true);
            // Do not manipulate browser history here; simply close the modal
        });
        
        // Render cart items
        function renderCartItems() {
            cartItemsContainer.innerHTML = '';
            
            if (cart.length === 0) {
                // Show empty cart with a big icon and hide summary/footer
                cartItemsContainer.innerHTML = '<div style="text-align:center; padding:40px 0;">' +
                    '<i class="fas fa-shopping-cart" style="font-size:48px;color: var(--light-gray); margin-bottom:10px;"></i>' +
                    '<p style="font-size:16px; color: var(--gray);">Savat bo\'sh</p>' +
                    '</div>';
                const cartSummaryEl = document.querySelector('.cart-summary');
                const cartFooterEl = document.querySelector('.cart-footer');
                if (cartSummaryEl) cartSummaryEl.style.display = 'none';
                if (cartFooterEl) cartFooterEl.style.display = 'none';
                // Still update the header count and reset prices
                subtotalPrice.textContent = '0 UZS';
                containersPrice.textContent = '0 UZS';
                totalPrice.textContent = '0 UZS';
                discountRow.style.display = 'none';
                return;
            } else {
                // Ensure summary and footer are visible when cart has items
                const cartSummaryEl = document.querySelector('.cart-summary');
                const cartFooterEl = document.querySelector('.cart-footer');
                if (cartSummaryEl) cartSummaryEl.style.display = 'block';
                if (cartFooterEl) cartFooterEl.style.display = 'flex';
            }
            
            cart.forEach((item, index) => {
                const cartItemElement = document.createElement('div');
                cartItemElement.className = 'cart-item';
                cartItemElement.innerHTML = `
                    <div class="cart-item-image" style="background-image: url('${item.image || '/public/images/no-image.jpg'}')"></div>
                    <div class="cart-item-info">
                        <div class="cart-item-name">${item.name} <span class="item-quantity">${item.quantity}x</span></div>
                        <div class="cart-item-variant">${item.variant.name}</div>
                        ${item.container ? `
                            <div class="cart-item-container">
                                ${item.container.name} <span class="container-quantity">${item.container.quantity || 1}x</span>
                            </div>
                        ` : ''}
                        <div class="cart-item-price">${(item.variant.price * item.quantity).toLocaleString()} UZS</div>
                    </div>
                    <div class="cart-item-actions">
                        <div class="cart-item-quantity">
                            <button class="cart-quantity-btn minus" data-index="${index}">-</button>
                            <input type="text" class="cart-quantity-input" value="${item.quantity}" readonly>
                            <button class="cart-quantity-btn plus" data-index="${index}">+</button>
                        </div>
                        ${item.container ? `
                            <div class="container-item-quantity">
                                <button class="cart-quantity-btn c-minus" data-index="${index}">-</button>
                                <input type="text" class="cart-quantity-input c-input" value="${item.container.quantity || 1}" readonly>
                                <button class="cart-quantity-btn c-plus" data-index="${index}">+</button>
                            </div>
                        ` : ''}
                        <div class="cart-item-remove" data-index="${index}">
                            <i class="fas fa-trash"></i>
                        </div>
                    </div>
                `;
                
                cartItemsContainer.appendChild(cartItemElement);
                
                // Mahsulot miqdori uchun +/- tugmalari
                const minusBtn = cartItemElement.querySelector('.minus');
                const plusBtn = cartItemElement.querySelector('.plus');
                const quantityInput = cartItemElement.querySelector('.cart-quantity-input');
                
                minusBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (item.quantity > 1) {
                        item.quantity--;
                        quantityInput.value = item.quantity;
                        cartItemElement.querySelector('.item-quantity').textContent = `${item.quantity}x`;
                        updateCart();
                    }
                });
                
                plusBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    item.quantity++;
                    quantityInput.value = item.quantity;
                    cartItemElement.querySelector('.item-quantity').textContent = `${item.quantity}x`;
                    updateCart();
                });
                
                // Idish miqdori uchun +/- tugmalari (agar idish mavjud bo'lsa)
                if (item.container) {
                    const cMinusBtn = cartItemElement.querySelector('.c-minus');
                    const cPlusBtn = cartItemElement.querySelector('.c-plus');
                    const cQuantityInput = cartItemElement.querySelector('.c-input');
                    
                    cMinusBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        if (item.container.quantity > 1) {
                            item.container.quantity--;
                            cQuantityInput.value = item.container.quantity;
                            cartItemElement.querySelector('.container-quantity').textContent = `${item.container.quantity}x`;
                            updateCart();
                        }
                    });
                    
                    cPlusBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        item.container.quantity++;
                        cQuantityInput.value = item.container.quantity;
                        cartItemElement.querySelector('.container-quantity').textContent = `${item.container.quantity}x`;
                        updateCart();
                    });
                }
                
                // O'chirish tugmasi
                const removeBtn = cartItemElement.querySelector('.cart-item-remove');
                removeBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    cart.splice(index, 1);
                    updateCart();
                });
            });
            // Remove any previous suggestions before adding new ones. The suggestions may reside
            // anywhere within the cart modal content (below the footer), so search globally inside
            // the cart modal.
            const existingSuggestions = document.querySelector('#cartModal .cart-modal-content .cart-suggestions');
            if (existingSuggestions) existingSuggestions.remove();

            // Intelligent suggestions: cross‑sell complementary products rather than
            // simply repeating the same category. When the cart has non‑drink
            // items we propose drinks; when it contains vegetables like 'sabzi'
            // we offer 'guruch'; otherwise we suggest products from new
            // categories not yet represented in the cart. See comments in the
            // `initHeroSlider` function for the initial slider behaviour.
            if (cart.length > 0) {
                // Gather category IDs present in the cart
                const categoriesInCart = new Set();
                cart.forEach(item => {
                    const dishObj = dishes.find(d => d.id === item.dishId);
                    if (dishObj && dishObj.category_id) categoriesInCart.add(dishObj.category_id);
                });
                // Determine beverage categories by name (Uzbek or English)
                const beverageCategoryIds = categories
                    .filter(cat => {
                        const name = (cat.name || '').toLowerCase();
                        return name.includes('ichimlik') || name.includes('drink');
                    })
                    .map(cat => cat.id);
                // Check if any cart item contains 'sabzi' in its name
                const cartContainsSabzi = cart.some(item => {
                    const dishObj = dishes.find(d => d.id === item.dishId);
                    return dishObj && dishObj.name && dishObj.name.toLowerCase().includes('sabzi');
                });
                let suggestions = [];
                // Suggest rice ('guruch') if there is carrot ('sabzi') in the cart
                if (cartContainsSabzi) {
                    suggestions = dishes.filter(d => {
                        return d.name && d.name.toLowerCase().includes('guruch') &&
                            !cart.some(ci => ci.dishId === d.id) &&
                            d.active !== false;
                    }).slice(0, 5);
                }
                // Cross‑sell beverages when there are savoury dishes
                if (suggestions.length === 0) {
                    const hasNonDrink = Array.from(categoriesInCart).some(id => !beverageCategoryIds.includes(id));
                    if (hasNonDrink) {
                        suggestions = dishes.filter(d => {
                            return beverageCategoryIds.includes(d.category_id) &&
                                !cart.some(ci => ci.dishId === d.id) &&
                                d.active !== false;
                        }).slice(0, 5);
                    } else {
                        // Otherwise offer dishes from categories not represented in the cart
                        suggestions = dishes.filter(d => {
                            return !categoriesInCart.has(d.category_id) &&
                                !cart.some(ci => ci.dishId === d.id) &&
                                d.active !== false;
                        }).slice(0, 5);
                    }
                }
                // Build and insert the suggestion elements
                if (suggestions.length > 0) {
                    const suggestionsDiv = document.createElement('div');
                    suggestionsDiv.className = 'cart-suggestions';
                    suggestionsDiv.innerHTML = '<h3>Balki yana nimadir kerakdir?</h3>';
                    const wrap = document.createElement('div');
                    wrap.className = 'suggestion-items';
                    suggestions.forEach(sug => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'suggestion-item';
                        const imageDiv = document.createElement('div');
                        imageDiv.className = 'image';
                        imageDiv.style.backgroundImage = `url('${sug.image || '/public/images/no-image.jpg'}')`;
                        const nameDiv = document.createElement('div');
                        nameDiv.className = 'name';
                        nameDiv.textContent = sug.name;
                        const priceDiv = document.createElement('div');
                        priceDiv.className = 'price';
                        priceDiv.textContent = sug.price ? sug.price.toLocaleString() + ' UZS' : '';
                        itemDiv.appendChild(imageDiv);
                        itemDiv.appendChild(nameDiv);
                        itemDiv.appendChild(priceDiv);
                        itemDiv.addEventListener('click', function() {
                            if (cartModal) {
                                cartModal.style.display = 'none';
                            }
                            openDishModal(sug.id);
                        });
                        wrap.appendChild(itemDiv);
                    });
                    suggestionsDiv.appendChild(wrap);
                    const cartModalContent = document.querySelector('#cartModal .cart-modal-content');
                    if (cartModalContent) {
                        cartModalContent.appendChild(suggestionsDiv);
                    } else {
                        cartItemsContainer.appendChild(suggestionsDiv);
                    }
                }
            }

            updateCartSummary();
        }
        
        // Update cart (save to localStorage and refresh UI)
        function updateCart() {
            localStorage.setItem('cart', JSON.stringify(cart));
            updateCartCount();
            renderCartItems();
        }
        
        // Update cart count in header
        function updateCartCount() {
            const totalItems = cart.reduce((total, item) => total + item.quantity, 0);
            // Update all cart count elements (header and bottom nav)
            document.querySelectorAll('.cart-count').forEach(countEl => {
                countEl.textContent = totalItems;
                // Show count only if there are items
                if (totalItems > 0) {
                    // For flex containers (e.g., nav) display should be flex; otherwise inline-block
                    countEl.style.display = 'flex';
                } else {
                    countEl.style.display = 'none';
                }
            });
        }
        
        // Update cart summary (subtotal, containers, delivery, total)
        function updateCartSummary() {
            // Calculate subtotal (only dishes)
            const subtotal = cart.reduce((total, item) => {
                return total + (item.variant.price * item.quantity);
            }, 0);
            
            // Calculate containers total (with quantity)
            const containersTotal = cart.reduce((total, item) => {
                if (item.container) {
                    return total + (item.container.price * (item.container.quantity || 1));
                }
                return total;
            }, 0);
            
            // Apply promo or cashback codes. Discounts only apply to the food subtotal.
            let discount = 0;
            let discountedSubtotal = subtotal;
            const appliedPromoCodeStr = localStorage.getItem('appliedPromoCode');
            const appliedCashbackStr = localStorage.getItem('appliedCashbackPromo');
            let promoCodeUsed = null;
            if (appliedPromoCodeStr) {
                try {
                    const promo = JSON.parse(appliedPromoCodeStr);
                    if (subtotal >= promo.min_sum) {
                        const promoDiscount = Math.min(promo.discount, subtotal);
                        discount += promoDiscount;
                        discountedSubtotal = subtotal - discount;
                        promoCodeUsed = promo.code;
                    }
                } catch (_) {}
            }
            if (appliedCashbackStr) {
                try {
                    const cb = JSON.parse(appliedCashbackStr);
                    const cbDiscount = Math.min(cb.balance, subtotal - discount);
                    discount += cbDiscount;
                    discountedSubtotal = subtotal - discount;
                    if (!promoCodeUsed) {
                        promoCodeUsed = cb.code;
                    }
                } catch (_) {}
            }
            // Show or hide the discount row based on whether any discount was applied
            if (discount > 0) {
                discountRow.style.display = 'flex';
                discountPrice.textContent = `-${discount.toLocaleString()} UZS`;
            } else {
                discountRow.style.display = 'none';
            }
            // Populate the promo code input(s) with whichever code is applied
            if (promoCodeUsed) {
                if (promoCodeInput) promoCodeInput.value = promoCodeUsed;
                if (checkoutPromoCodeInput) checkoutPromoCodeInput.value = promoCodeUsed;
            }
            // Calculate total: discounted food + containers (delivery not included here)
            const total = discountedSubtotal + containersTotal;
            // Update UI - the cart summary shows discounted food and container costs.
            subtotalPrice.textContent = discountedSubtotal.toLocaleString() + ' UZS';
            containersPrice.textContent = containersTotal.toLocaleString() + ' UZS';
            totalPrice.textContent = total.toLocaleString() + ' UZS';
        }

        /**
         * Haversine distance in kilometres between two lat/lng points.
         * Returns 0 if any coordinate is missing.
         */
        /**
         * Haversine distance in kilometres between two lat/lng points.
         * Returns 0 if any coordinate is missing.
         */
        function getDistance(lat1, lon1, lat2, lon2) {
            // Fallback Haversine distance in kilometres between two lat/lng points.
            // Returns 0 if any coordinate is missing.
            if (lat1 === undefined || lon1 === undefined || lat2 === undefined || lon2 === undefined) return 0;
            const R = 6371; // Earth radius in km
            const toRad = deg => deg * Math.PI / 180;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        /**
         * Fetch the real-world walking distance between two coordinates using
         * the OpenRouteService Directions API.
         */
        const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjQ5YTE1NmI3NzZhNTQ4OWNiOTE4ODQ3MWFmNzdhNDZmIiwiaCI6Im11cm11cjY0In0='; // O'zingizning API keyingizni qo'ying
        const ORS_PROFILE = 'foot-walking';
        async function getRouteDistance(lat1, lon1, lat2, lon2) {
            try {
                const start = `${lon1},${lat1}`;
                const end = `${lon2},${lat2}`;
                const url = `https://api.openrouteservice.org/v2/directions/${ORS_PROFILE}?api_key=${ORS_API_KEY}&start=${start}&end=${end}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('ORS request failed');
                const data = await response.json();
                // The distance is provided in metres; convert to kilometres
                const metres = data.features?.[0]?.properties?.summary?.distance;
                if (typeof metres === 'number' && !isNaN(metres)) {
                    return metres / 1000;
                }
                // Fallback if the response format is unexpected
                return getDistance(lat1, lon1, lat2, lon2);
            } catch (error) {
                // On any failure, gracefully return the Haversine distance
                return getDistance(lat1, lon1, lat2, lon2);
            }
        }

        /**
         * Calculate total delivery path distance in kilometres.
         * Starts from the user's selected location, visits the nearest restaurant,
         * then each additional restaurant in order of proximity to the user.
         * If no location is selected or restaurants have no coordinates, returns 0.
         */
        /**
         * Calculate total delivery path distance in kilometres.
         * Uses OpenRouteService for accurate walking distance calculations.
         */
        async function calculateDeliveryDistanceKm() {
            // Return 0 if the user has not selected a location
            if (!userLocation) return 0;
            const restPositions = [];
            const seen = {};
            // Collect unique restaurant coordinates from the cart
            cart.forEach(item => {
                if (!seen[item.restaurantId]) {
                    const rest = restaurants.find(r => r.id === item.restaurantId);
                    if (rest) {
                        let lat = rest.lat;
                        let lng = rest.lng;
                        // Fallbacks for different property names
                        if (lat === undefined && rest.location) lat = rest.location.lat || rest.location.latitude;
                        if (lng === undefined && rest.location) lng = rest.location.lng || rest.location.longitude || rest.location.lon;
                        if (lat === undefined) lat = rest.latitude;
                        if (lng === undefined) lng = rest.longitude || rest.lon;
                        if (lat !== undefined && lng !== undefined) {
                            restPositions.push({ lat: parseFloat(lat), lng: parseFloat(lng) });
                        }
                        seen[item.restaurantId] = true;
                    }
                }
            });
            if (restPositions.length === 0) return 0;
            
            // Compute distances from the user to each restaurant using ORS
            const distancesFromUser = await Promise.all(
                restPositions.map(pos => getRouteDistance(userLocation.lat, userLocation.lng, pos.lat, pos.lng))
            );
            restPositions.forEach((pos, idx) => pos.distanceFromUser = distancesFromUser[idx]);
            
            // Sort by walking distance from the user
            restPositions.sort((a, b) => a.distanceFromUser - b.distanceFromUser);
            
            // Start with the distance from the user to the closest restaurant
            let total = restPositions[0].distanceFromUser;
            
            // Add distances between consecutive restaurants
            for (let i = 0; i < restPositions.length - 1; i++) {
                const cur = restPositions[i];
                const next = restPositions[i + 1];
                const d = await getRouteDistance(cur.lat, cur.lng, next.lat, next.lng);
                total += d;
            }
            
            return total;
        }

        /**
         * Calculate delivery cost based on total distance.
         * Returns null if distance exceeds 30 km (not deliverable).
         */
        /**
         * Calculate delivery cost based on total walking distance.
         * Returns null if distance exceeds 30 km (not deliverable).
         */
        async function calculateDeliveryCost() {
            const distance = await calculateDeliveryDistanceKm();
            if (!distance || distance === 0) return 0;
            // If the route exceeds 30 km it is considered out of range
            if (distance > 30) return null;
            if (distance <= 3) return 10000;
            return 10000 + (Math.ceil(distance) - 3) * 1800;
        }

        /**
         * Update summary in checkout modal: order, containers and delivery costs.
         */
        /**
         * Update summary in checkout modal: order, containers and delivery costs.
         */
        async function updateCheckoutSummary() {
            if (!checkoutSubtotal || !checkoutContainers || !checkoutDelivery) return;
            // Compute subtotal (dishes only) and containers
            const subtotal = cart.reduce((total, item) => total + (item.variant.price * item.quantity), 0);
            const containersTotal = cart.reduce((total, item) => {
                if (item.container) {
                    return total + (item.container.price * (item.container.quantity || 1));
                }
                return total;
            }, 0);
            // Compute the delivery cost asynchronously
            const deliveryCost = await calculateDeliveryCost();
            // Apply promo or cashback discount to the food subtotal only
            let discount = 0;
            let discountedSubtotal = subtotal;
            const appliedPromoCodeStr = localStorage.getItem('appliedPromoCode');
            const appliedCashbackStr = localStorage.getItem('appliedCashbackPromo');
            if (appliedPromoCodeStr) {
                try {
                    const promo = JSON.parse(appliedPromoCodeStr);
                    if (subtotal >= promo.min_sum) {
                        const promoDiscount = Math.min(promo.discount, subtotal);
                        discount += promoDiscount;
                    }
                } catch (_) {}
            }
            if (appliedCashbackStr) {
                try {
                    const cb = JSON.parse(appliedCashbackStr);
                    const cbDiscount = Math.min(cb.balance, subtotal - discount);
                    discount += cbDiscount;
                } catch (_) {}
            }
            discountedSubtotal = subtotal - discount;
            // Total amount including containers and delivery
            const total = discountedSubtotal + containersTotal + (deliveryCost || 0);
            // Update fields: show discounted food price and computed totals
            checkoutSubtotal.textContent = discountedSubtotal.toLocaleString() + ' UZS';
            checkoutContainers.textContent = containersTotal.toLocaleString() + ' UZS';
            if (deliveryCost === null) {
                checkoutDelivery.textContent = 'siz juda uzoqdasiz!';
            } else {
                checkoutDelivery.textContent = deliveryCost.toLocaleString() + ' UZS';
            }
            // If the total element exists, update it
            const checkoutTotalEl = document.getElementById('checkoutTotal');
            if (checkoutTotalEl) {
                checkoutTotalEl.textContent = total.toLocaleString() + ' UZS';
            }
        }
        
        // Apply promo code from cart (if element exists)
        if (applyPromoCodeBtn && promoCodeInput) {
            applyPromoCodeBtn.addEventListener('click', async function() {
                const code = promoCodeInput.value.trim();
                if (!code) return;
                // First try to find a standard promotional code configured by the admin
                const promo = promocodes.find(p => p.code.toLowerCase() === code.toLowerCase());
                const subtotal = cart.reduce((total, item) => {
                    return total + (item.variant.price * item.quantity);
                }, 0);
                if (promo) {
                    // Validate minimum order amount for standard promo codes
                    if (subtotal < promo.min_sum) {
                        alert(`Promo kod uchun minimal summa: ${promo.min_sum.toLocaleString()} UZS`);
                        return;
                    }
                    // Store the standard promo code.  Do not remove any existing cashback promo
                    // so that both discounts can be applied together.  Overwrite any
                    // previously stored standard promo code.
                    localStorage.setItem('appliedPromoCode', JSON.stringify(promo));
                    updateCartSummary();
                    alert('Promo kod muvaffaqiyatli qo\'llandi!');
                } else {
                    // If not a standard promo, treat it as a customer‑specific cashback promo code
                    try {
                        const resp = await fetch(`${API_BASE_URL}/promocode/${encodeURIComponent(code)}`);
                        if (!resp.ok) {
                            alert('Noto\'g\'ri promo kod!');
                            return;
                        }
                        const data = await resp.json();
                        const balance = data.cashback || 0;
                        if (balance < 10000) {
                            alert(`Keshbekni ishlatish uchun kamida 10,000 so'm kerak. Sizda ${balance.toLocaleString()} so'm mavjud.`);
                            return;
                        }
                        // Store the cashback promo details so that it can be deducted upon checkout.
                        // Do not remove any existing standard promo code so both discounts can coexist.
                        localStorage.setItem('appliedCashbackPromo', JSON.stringify({ code: data.promoCode, phone: data.phone, balance: balance }));
                        updateCartSummary();
                        alert('Keshbek promo kodi muvaffaqiyatli qo\'llandi!');
                    } catch (err) {
                        console.error('Failed to validate promo code', err);
                        alert('Promo kodni tekshirishda xatolik yuz berdi');
                    }
                }
            });
        }

        // Apply promo code from checkout (if element exists)
        if (checkoutApplyPromoCodeBtn && checkoutPromoCodeInput) {
            checkoutApplyPromoCodeBtn.addEventListener('click', async function() {
                const code = checkoutPromoCodeInput.value.trim();
                if (!code) return;
                const promo = promocodes.find(p => p.code.toLowerCase() === code.toLowerCase());
                const subtotal = cart.reduce((total, item) => {
                    return total + (item.variant.price * item.quantity);
                }, 0);
                if (promo) {
                    if (subtotal < promo.min_sum) {
                        alert(`Promo kod uchun minimal summa: ${promo.min_sum.toLocaleString()} UZS`);
                        return;
                    }
                    // Store the standard promo code; allow any existing cashback promo to remain.
                    localStorage.setItem('appliedPromoCode', JSON.stringify(promo));
                    updateCartSummary();
                    updateCheckoutSummary();
                    alert('Promo kod muvaffaqiyatli qo\'llandi!');
                } else {
                    // Treat as cashback promo code
                    try {
                        const resp = await fetch(`${API_BASE_URL}/promocode/${encodeURIComponent(code)}`);
                        if (!resp.ok) {
                            alert('Noto\'g\'ri promo kod!');
                            return;
                        }
                        const data = await resp.json();
                        const balance = data.cashback || 0;
                        if (balance < 10000) {
                            alert(`Keshbekni ishlatish uchun kamida 10,000 so'm kerak. Sizda ${balance.toLocaleString()} so'm mavjud.`);
                            return;
                        }
                        localStorage.setItem('appliedCashbackPromo', JSON.stringify({ code: data.promoCode, phone: data.phone, balance: balance }));
                        updateCartSummary();
                        updateCheckoutSummary();
                        alert('Keshbek promo kodi muvaffaqiyatli qo\'llandi!');
                    } catch (err) {
                        console.error('Failed to validate promo code', err);
                        alert('Promo kodni tekshirishda xatolik yuz berdi');
                    }
                }
            });
        }
        
        // Open checkout modal
        checkoutBtn.addEventListener('click', function() {
            if (cart.length === 0) return;
            
            // Check business hours
            if (!isBusinessHours) {
                // If outside of business hours, show the closed modal instead of an alert
                showClosedModal();
                return;
            }
            // Check minimal order amount (food + containers) must be >= 20,000 UZS
            const subtotal = cart.reduce((total, item) => total + (item.variant.price * item.quantity), 0);
            const containersTotal = cart.reduce((total, item) => {
                if (item.container) {
                    return total + (item.container.price * (item.container.quantity || 1));
                }
                return total;
            }, 0);
            const orderSum = subtotal + containersTotal;
            if (orderSum < 20000) {
                alert('Buyurtma berish uchun kamida 20,000 soʻmlik mahsulot xarid qilishingiz kerak!');
                return;
            }
            // Initialize map if not already initialized
            if (!map) {
                initMap();
            }
            // Update checkout summary when opening
            updateCheckoutSummary();
            // Hide hero slider in checkout
            showHeroSlider(false);
            // Open modal
            checkoutModal.style.display = 'block';
            // Push history state for checkout
            try {
                history.pushState({ modal: 'checkout' }, '', '');
            } catch (_) {}
        });
        
        // Close checkout modal
        closeCheckoutModalBtn.addEventListener('click', function() {
            checkoutModal.style.display = 'none';
            try {
                history.back();
            } catch (_) {}
        });
        
        // Initialize Yandex map
        function initMap() {
            // Prevent re-initialisation
            if (map) return;
            ymaps.ready(function() {
                map = new ymaps.Map('map', {
                    center: [41.311081, 69.240562],
                    zoom: 13,
                    // Enable zoom and geolocation controls on the map overlay. These controls allow
                    // the user to zoom in/out and automatically detect their current position.
                    controls: ['zoomControl', 'geolocationControl']
                });
                // When the user clicks on the map, place a marker and perform reverse
                // geocoding to obtain the address. The result is displayed in the
                // location input field and used for order calculations.
                map.events.add('click', function(e) {
                    const coords = e.get('coords');
                    setUserLocation(coords, true);
                });
            });
        }

        // Helper to set user location on map and optionally reverse geocode
        function setUserLocation(coords, doReverseGeocode) {
            if (!coords || coords.length < 2) return;
            // coords expected as [lat, lng]
            const lat = Array.isArray(coords) ? coords[0] : coords.lat;
            const lng = Array.isArray(coords) ? coords[1] : coords.lng;
            userLocation = { lat: lat, lng: lng };
            // Place or move marker.  Use a blue location icon instead of the default
            // red pin.  The `islands#blueIcon` preset draws the familiar
            // location pin in blue.  If the marker does not exist yet we
            // create it, otherwise we move it to the new coordinates.  We
            // intentionally do not recenter the map here because on mobile the
            // map should stay where the user has panned – recentering on every
            // click caused the marker to always appear in the middle of the
            // viewport.
            if (!marker) {
                marker = new ymaps.Placemark([lat, lng], {}, { preset: 'islands#blueIcon' });
                map.geoObjects.add(marker);
            } else {
                marker.geometry.setCoordinates([lat, lng]);
            }
            // Do not automatically center the map after setting the marker.
            if (doReverseGeocode) {
                // Use Nominatim reverse geocoding instead of Yandex geocode to avoid API key issues
                fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`)
                    .then(response => response.json())
                    .then(data => {
                        const address = data.display_name || 'Manzil aniqlanmadi';
                        locationInput.value = address;
                        updateCheckoutSummary();
                    })
                    .catch(() => {
                        locationInput.value = 'Manzil aniqlanmadi';
                        updateCheckoutSummary();
                    });
            }
        }
        
        // ----------------------------------------------------------------------
        // Location selection handlers
        // ----------------------------------------------------------------------
        // When the user taps the "Xaritadan tanlash" button, open the map overlay.
        selectLocationBtn.addEventListener('click', function() {
            // Ensure the map is initialised
            if (!map) initMap();
            // Display the overlay and hide the hero slider to maximise space
            if (mapOverlay) mapOverlay.style.display = 'block';
            showHeroSlider(false);
            // If a location has already been selected, centre the map on it
            if (userLocation && userLocation.lat !== undefined && userLocation.lng !== undefined) {
                setUserLocation([userLocation.lat, userLocation.lng], false);
            }
            // Push state so that the back button will close the overlay instead of
            // navigating away from the site
            try {
                history.pushState({ modal: 'map' }, '', '');
            } catch (_) {}
        });

        // Use current location from the checkout form (outside the overlay). This
        // does not open the map overlay but simply requests the device's
        // geolocation and updates the location fields.
        useCurrentLocationBtn.addEventListener('click', function() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const coords = [position.coords.latitude, position.coords.longitude];
                        // Update location and perform reverse geocode
                        setUserLocation(coords, true);
                    },
                    function(error) {
                        alert('Joylashuvni aniqlab bo\'lmadi: ' + error.message);
                    }
                );
            } else {
                alert('Brauzeringiz joylashuv xizmatini qo\'llab-quvvatlamaydi');
            }
        });

        // In the map overlay, the user can also request their current location. This
        // uses the same geolocation API but ensures the map is initialised.
        if (useCurrentLocationOverlayBtn) {
            useCurrentLocationOverlayBtn.addEventListener('click', function() {
                if (!map) initMap();
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            const coords = [position.coords.latitude, position.coords.longitude];
                            // Mapni yangi joylashuvga markazlash
                            map.setCenter(coords, 17); // 17 - zoom level
                            // Belgilagichni o'rnatish
                            setUserLocation(coords, true);
                        },
                        function(error) {
                            alert('Joylashuvni aniqlab bo\'lmadi: ' + error.message);
                        }
                    );
                } else {
                    alert('Brauzeringiz joylashuv xizmatini qo\'llab-quvvatlamaydi');
                }
            });
        }

        // Close the map overlay when the close button is clicked and go back in
        // browser history. Also hide any suggestion dropdown.
        if (closeMapOverlayBtn) {
            closeMapOverlayBtn.addEventListener('click', function() {
                if (mapOverlay) mapOverlay.style.display = 'none';
                if (mapSearchSuggestions) {
                    mapSearchSuggestions.innerHTML = '';
                    mapSearchSuggestions.style.display = 'none';
                }
                // Do not explicitly toggle the hero slider here; the popstate handler
                // will restore the appropriate state (e.g. hide slider during checkout).
                try {
                    history.back();
                } catch (_) {}
            });
        }

        // Confirm the selected location: save the address and coordinates to
        // localStorage, update the last location container, and close the overlay.
        if (confirmLocationBtn) {
            confirmLocationBtn.addEventListener('click', function() {
                // Only save if a location has been selected and the input contains a value
                if (userLocation && locationInput && locationInput.value) {
                    try {
                        localStorage.setItem('lastAddress', locationInput.value);
                        localStorage.setItem('lastCoords', JSON.stringify(userLocation));
                        // Update the last location display
                        const lastLoc = document.getElementById('lastLocationContainer');
                        if (lastLoc) {
                            lastLoc.textContent = `SIZNING MANZILINGIZ: ${locationInput.value}`;
                        }
                    } catch (_) {}
                }
                if (mapOverlay) mapOverlay.style.display = 'none';
                if (mapSearchSuggestions) {
                    mapSearchSuggestions.innerHTML = '';
                    mapSearchSuggestions.style.display = 'none';
                }
                // Do not explicitly toggle the hero slider; rely on popstate handler
                try {
                    history.back();
                } catch (_) {}
            });
        }
        
        // Select payment method
        paymentMethods.forEach(method => {
            method.addEventListener('click', function() {
                paymentMethods.forEach(m => m.classList.remove('selected'));
                this.classList.add('selected');
                selectedPaymentMethod = this.dataset.method;
            });
        });
        
        // Place order
        placeOrderBtn.addEventListener('click', async function() {
            // Validate form
            if (!customerName.value.trim()) {
                alert('Ismingizni kiritishni unutdingiz!');
                return;
            }
            
            if (!customerPhone.value.trim()) {
                alert('Iltimos, telefon raqamingizni kiriting');
                return;
            }
            
            if (!userLocation) {
                alert('Iltimos, yetkazib berish manzilini belgilang!');
                return;
            }
            
            // Calculate delivery cost and validate distance
            const deliveryCost = await calculateDeliveryCost();
            if (deliveryCost === null) {
                alert('Kechirasiz, hozircha sizning hududingizga yetkazib bera olmaymiz!');
                return;
            }
            // Compute the subtotal of items (excluding containers) for potential cashback use
            const itemsSubtotal = cart.reduce((sum, item) => sum + (item.variant.price * item.quantity), 0);

            // Prepare order data object here so we can augment it with promo and cashback discounts
            const orderData = {
                customer: {
                    name: customerName.value.trim(),
                    phone: customerPhone.value.trim(),
                    note: customerNote.value.trim(),
                    location: userLocation
                },
                items: cart.map(item => ({
                    dishId: item.dishId,
                    restaurantId: item.restaurantId,
                    name: item.name,
                    variant: item.variant,
                    container: item.container,
                    quantity: item.quantity,
                    price: item.variant.price
                })),
                paymentMethod: selectedPaymentMethod,
                deliveryCost: deliveryCost,
                timestamp: new Date().toISOString()
            };

            // Calculate applicable discounts from stored promo codes
            const appliedPromoCodeStr = localStorage.getItem('appliedPromoCode');
            const appliedCashbackStr = localStorage.getItem('appliedCashbackPromo');
            let discountTotal = 0;
            let promoCodeForOrder = null;
            let cashbackUsed = 0;
            // Apply standard promo code first (if present and valid for the subtotal)
            if (appliedPromoCodeStr) {
                try {
                    const promo = JSON.parse(appliedPromoCodeStr);
                    if (itemsSubtotal >= promo.min_sum) {
                        const promoDiscount = Math.min(promo.discount, itemsSubtotal);
                        discountTotal += promoDiscount;
                        promoCodeForOrder = promo.code;
                    }
                } catch (_) {}
            }
            // Apply cashback promo code next
            if (appliedCashbackStr) {
                try {
                    const cb = JSON.parse(appliedCashbackStr);
                    // Only apply if there is a positive balance and the threshold was met during validation
                    const remainingAfterPromo = itemsSubtotal - discountTotal;
                    const cbDiscount = Math.min(cb.balance, remainingAfterPromo);
                    discountTotal += cbDiscount;
                    cashbackUsed = cbDiscount;
                } catch (_) {}
            }
            if (discountTotal > 0) {
                orderData.discount = discountTotal;
            }
            if (promoCodeForOrder) {
                orderData.promoCode = promoCodeForOrder;
            }
            if (cashbackUsed > 0) {
                orderData.cashbackUsed = cashbackUsed;
            }
            
            try {
                // Send order to server and parse response
                const response = await fetch(`${API_BASE_URL}/orders`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(orderData)
                });
                if (response.ok) {
                    const result = await response.json();
                    // If a cashback promo was used, persist the deduction on the server
                    if (cashbackUsed > 0) {
                        try {
                            await fetch(`${API_BASE_URL}/promocode/apply`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ code: JSON.parse(localStorage.getItem('appliedCashbackPromo')).code, amount: cashbackUsed })
                            });
                        } catch (err) {
                            console.error('Failed to apply cashback promo code', err);
                        }
                    }
                    // Clear cart and any applied promo/cashback codes
                    cart = [];
                    localStorage.removeItem('cart');
                    localStorage.removeItem('appliedPromoCode');
                    localStorage.removeItem('appliedCashbackPromo');
                    // Update UI
                    updateCartCount();
                    // Close modals
                    cartModal.style.display = 'none';
                    checkoutModal.style.display = 'none';
                    // Build success message based on cashback award
                    const successMsgEl = successModal.querySelector('.success-message');
                    if (successMsgEl) {
                        if (result && typeof result.cashbackAdded === 'number' && result.cashbackAdded > 0) {
                            const added = result.cashbackAdded.toLocaleString();
                            const balance = (result.cashbackBalance || 0).toLocaleString();
                            // Do not show the promo code directly on the site.  Instead,
                            // direct the customer to the Telegram bot where they can view
                            // their cashback promo code.  Showing the code here would
                            // duplicate it in the browser, which is against the new
                            // requirements.
                            successMsgEl.innerHTML = `Xizmatimizdan foydalanganingiz uchun tashakkur!<br>` +
                                `Sizni yana kutib qolamiz! ♥️<br>` +
                                `Sizga xaridingiz uchun ${added} so'm keshbek berildi 🎉<br>` +
                                `Balansingiz va keshbek promo kodingizni telegram botimizning 💵 Balansim bo'limida topishingiz mumkin.<br><br>` +
                                `Buyurtmangiz holatini pastdagi tugmani bosish orqali telegram botimizda kuzatishingiz mumkin!`;
                        } else {
                            // Fallback when no cashback was awarded
                            successMsgEl.innerHTML = `Xizmatimizdan foydalanganingiz uchun tashakkur!<br>` +
                                `Sizni yana kutib qolamiz! ♥️<br>` +
                                `Buyurtmangiz holatini pastdagi tugmani bosish orqali telegram botimizda kuzatishingiz mumkin!`;
                        }
                    }
                    // Show success modal
                    successModal.style.display = 'block';
                } else {
                    alert('Buyurtma yuborishda xatolik yuz berdi');
                }
            } catch (error) {
                console.error('Failed to place order:', error);
                alert('Buyurtma yuborishda xatolik yuz berdi');
            }
        });
        
        // Close success modal
        closeSuccessModalBtn.addEventListener('click', function() {
            successModal.style.display = 'none';
        });

        // Open Telegram bot link from success modal
        if (trackOrderBtn) {
            trackOrderBtn.addEventListener('click', function() {
                // Open the KAGO telegram bot in a new tab
                window.open('https://t.me/kagoobot', '_blank');
            });
        }

        // -------------------------------------------
        // Browser history handling
        // -------------------------------------------
        // Intercept browser back/forward navigation. This handler ensures that when
        // the user presses the back button while a modal or secondary page is open,
        // the app will close the current view rather than navigating away from
        // the site entirely. Each view pushes its own state when opened.
        window.addEventListener('popstate', function(e) {
            const state = e.state;
            // No state or home page state
            if (!state || state.page === 'home') {
                // Close any open modals
                dishModal.style.display = 'none';
                cartModal.style.display = 'none';
                checkoutModal.style.display = 'none';
                successModal.style.display = 'none';
                closedModal.style.display = 'none';
                const restModalEl = document.getElementById('restaurantsModal');
                if (restModalEl) restModalEl.style.display = 'none';
                // Render home page
                renderRestaurants();
                showHeroSlider(true);
                // Highlight home nav
                document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
                if (homeNavBtn) homeNavBtn.classList.add('active');
            } else if (state.page === 'favorites') {
                // Show favorites page
                renderFavorites();
                showHeroSlider(false);
                document.querySelectorAll('.bottom-nav .nav-item').forEach(item => item.classList.remove('active'));
                if (favoritesNavBtn) favoritesNavBtn.classList.add('active');
            } else if (state.modal === 'cart') {
                openCartModal();
            } else if (state.modal === 'checkout') {
                // Only open checkout if there are items in cart
                if (cart && cart.length > 0) {
                    updateCheckoutSummary();
                    checkoutModal.style.display = 'block';
                }
            } else if (state.modal === 'map') {
                // Reopen the map overlay when navigating back to it
                if (!map) initMap();
                if (mapOverlay) mapOverlay.style.display = 'block';
                showHeroSlider(false);
            } else if (state.modal === 'dish' && state.dishId) {
                openDishModal(state.dishId);
            } else if (state.modal === 'restaurants') {
                openRestaurantsModal();
            } else if (state.modal === 'restaurant' && state.restaurantId) {
                showRestaurantDishes(state.restaurantId);
            } else if (state.modal === 'branch-type' && state.typeId) {
                // Restore branch type modal when navigating back
                openBranchTypeModal(state.typeId);
            } else if (state.modal === 'category' && state.categoryId) {
                // Restore category modal when navigating back
                openCategoryModal(state.categoryId);
            }
        });
        
        // Close modal when clicking outside
        window.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal')) {
                // Hide all modals
                dishModal.style.display = 'none';
                cartModal.style.display = 'none';
                checkoutModal.style.display = 'none';
                successModal.style.display = 'none';
                closedModal.style.display = 'none';
                const restModalEl = document.getElementById('restaurantsModal');
                if (restModalEl) restModalEl.style.display = 'none';
                // Restore hero slider when closing overlays
                showHeroSlider(true);
                // Re-enable page scrolling
                document.body.style.overflow = '';
                // Do not change browser history when clicking outside a modal
            }
        });

        // Search functionality for map using Nominatim API
        const mapSearchInputElem = document.getElementById('mapSearchInput');
        // Handle map search: suggestions while typing and search on Enter
        if (mapSearchInputElem) {
            // Search on Enter key
            mapSearchInputElem.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const query = mapSearchInputElem.value.trim();
                    if (!query) return;
                    // Hide suggestions
                    if (mapSearchSuggestions) {
                        mapSearchSuggestions.innerHTML = '';
                        mapSearchSuggestions.style.display = 'none';
                    }
                    // Query Nominatim search API for address
                    fetch(`https://nominatim.openstreetmap.org/search?format=json&countrycodes=uz&q=${encodeURIComponent(query)}&limit=1`)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.length > 0) {
                                const result = data[0];
                                const lat = parseFloat(result.lat);
                                const lon = parseFloat(result.lon);
                                // Set user location without reverse geocode (we already have address)
                                setUserLocation([lat, lon], false);
                                // Pan the map smoothly to the searched location so that the marker and view are aligned
                                if (map) {
                                    try {
                                        map.panTo([lat, lon], {
                                            flying: true,
                                            duration: 500
                                        });
                                    } catch (_) {
                                        // Fallback: directly centre the map if panTo fails
                                        map.setCenter([lat, lon], 17);
                                    }
                                }
                                // Update visible address
                                if (locationInput) locationInput.value = result.display_name || query;
                                updateCheckoutSummary();
                            } else {
                                alert('Manzil topilmadi');
                            }
                        })
                        .catch(() => {
                            alert('Qidirish jarayonida xatolik yuz berdi');
                        });
                }
            });
            // Suggestions on input
            let mapSearchDebounce;
            mapSearchInputElem.addEventListener('input', function() {
                const query = this.value.trim();
                // If query is empty, hide suggestions
                if (!query) {
                    if (mapSearchSuggestions) {
                        mapSearchSuggestions.innerHTML = '';
                        mapSearchSuggestions.style.display = 'none';
                    }
                    return;
                }
                // Debounce API requests
                clearTimeout(mapSearchDebounce);
                mapSearchDebounce = setTimeout(() => {
                    fetch(`https://nominatim.openstreetmap.org/search?format=json&countrycodes=uz&q=${encodeURIComponent(query)}&limit=5`)
                        .then(response => response.json())
                        .then(data => {
                            if (mapSearchSuggestions) {
                                mapSearchSuggestions.innerHTML = '';
                                if (data && data.length > 0) {
                                    data.forEach(item => {
                                        const li = document.createElement('li');
                                        li.textContent = item.display_name;
                                        li.style.padding = '8px 12px';
                                        li.style.cursor = 'pointer';
                                        li.addEventListener('click', function() {
                                            // Populate search input
                                            mapSearchInputElem.value = item.display_name;
                                            // Hide suggestions
                                            mapSearchSuggestions.innerHTML = '';
                                            mapSearchSuggestions.style.display = 'none';
                                            // Update user location without reverse geocode
                                            const lat = parseFloat(item.lat);
                                            const lon = parseFloat(item.lon);
                                            setUserLocation([lat, lon], false);
                                            // Pan the map smoothly to the selected suggestion
                                            if (map) {
                                                try {
                                                    map.panTo([lat, lon], {
                                                        flying: true,
                                                        duration: 500
                                                    });
                                                } catch (_) {
                                                    map.setCenter([lat, lon], 17);
                                                }
                                            }
                                            // Update location input and summary
                                            if (locationInput) locationInput.value = item.display_name;
                                            updateCheckoutSummary();
                                        });
                                        mapSearchSuggestions.appendChild(li);
                                    });
                                    mapSearchSuggestions.style.display = 'block';
                                } else {
                                    mapSearchSuggestions.style.display = 'none';
                                }
                            }
                        })
                        .catch(() => {
                            if (mapSearchSuggestions) {
                                mapSearchSuggestions.innerHTML = '';
                                mapSearchSuggestions.style.display = 'none';
                            }
                        });
                }, 300);
            });

            // Clear search input when the clear button is clicked
            const mapClearButton = document.getElementById('mapClearButton');
            if (mapClearButton) {
                mapClearButton.addEventListener('click', function() {
                    // Empty the input field
                    mapSearchInputElem.value = '';
                    // Hide any suggestion dropdown
                    if (mapSearchSuggestions) {
                        mapSearchSuggestions.innerHTML = '';
                        mapSearchSuggestions.style.display = 'none';
                    }
                });
            }
        }

        /* ------------------------------------------------------------------
         * Kago Kago AI Chat
         *
         * The following code implements a simple chat interface that
         * communicates with a server‑side proxy for OpenAI’s ChatGPT API.
         * The assistant introduces itself as "Kago agent" and answers
         * questions based solely on the current site data (restaurants,
         * dishes, branch types and working hours). A context string is
         * generated from these datasets once at initial load; see
         * buildAgentContext() below. The conversation history is persisted
         * across messages so the model has context about prior questions.
         */
        // Elements for the chat modal
        const agentModal = document.getElementById('agentModal');
        const agentNavBtn = document.getElementById('agentNavBtn');
        const closeAgentModal = document.getElementById('closeAgentModal');
        const agentMessagesEl = document.getElementById('agentMessages');
        const agentInput = document.getElementById('agentInput');
        const agentSendBtn = document.getElementById('agentSendBtn');

        // Conversation state: an array of messages excluding the system prompt
        let agentConversation = [];
        // System prompt instructing the AI how to behave. The context string
        // containing current data will be appended by buildAgentContext().
        let agentSystemPrompt = 'You are Kago agent, a helpful assistant for the KAGO delivery website. ' +
            'You answer user questions about branch names, product counts, working hours, delivery fees and other information available on the site. ' +
            'Always introduce yourself as "Kago agent" at the beginning of every reply. If the answer is not present in the provided data, say that you do not know.';
        // Context to be generated from current datasets
        let agentContext = '';

        /**
         * Build a textual context from the current site data. This uses the
         * globally defined `restaurants`, `dishes`, `branchTypes` and
         * `workhours` variables which are populated via API calls during
         * loadInitialData(). The resulting string summarises available
         * restaurants, dishes and branch types with their counts and names,
         * and lists the opening hours for each day. This allows the AI to
         * answer common queries without direct access to the data structures.
         */
        function buildAgentContext() {
            try {
                const restSummary = (restaurants || []).map(r => r.name).join(', ');
                const dishSummary = (dishes || []).map(d => `${d.name} (${d.price || ''} UZS, ${d.restaurant_id})`).join('; ');
                const typeSummary = (branchTypes || []).map(bt => bt.name).join(', ');
                // Fetch work hours from API synchronously if not already loaded
                const workhoursPromise = fetch(`${API_BASE_URL}/workhours`).then(res => res.json()).catch(() => null);
                Promise.resolve(workhoursPromise).then(wh => {
                    let hoursStr = '';
                    if (wh) {
                        hoursStr = Object.keys(wh).map(day => `${day}: ${wh[day].start}–${wh[day].end}`).join(', ');
                    }
                    agentContext = `Available restaurants: ${restSummary}. Available dishes: ${dishSummary}. ` +
                                   `Branch types: ${typeSummary}. Working hours: ${hoursStr}.`;
                });
            } catch (err) {
                agentContext = '';
            }
        }

        /**
         * Append a message to the chat window. Messages from the user and the
         * agent are styled differently. This does not send any data to the
         * server; it merely updates the DOM.
         * @param {'user'|'agent'} role
         * @param {string} content
         */
        function appendAgentMessage(role, content) {
            if (!agentMessagesEl) return;
            const wrapper = document.createElement('div');
            wrapper.className = `chat-message ${role}`;
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            bubble.textContent = content;
            wrapper.appendChild(bubble);
            agentMessagesEl.appendChild(wrapper);
            // Auto-scroll to bottom
            agentMessagesEl.scrollTop = agentMessagesEl.scrollHeight;
        }

        /**
         * Send the user’s message to the server to obtain a response from
         * OpenAI. The conversation history (agentConversation) is included
         * alongside a system prompt and data context. On receiving a reply,
         * the assistant’s message is appended and the state updated.
         */
        async function handleAgentSend() {
            const text = agentInput && agentInput.value ? agentInput.value.trim() : '';
            if (!text) return;
            // Clear the input field and echo the user message immediately
            agentInput.value = '';
            appendAgentMessage('user', text);
            // Add to local history
            agentConversation.push({ role: 'user', content: text });
            try {
                const payloadMessages = [];
                // Prepend system prompt and current context
                payloadMessages.push({ role: 'system', content: `${agentSystemPrompt}\n\n${agentContext}` });
                // Include prior messages
                agentConversation.forEach(msg => payloadMessages.push(msg));
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ messages: payloadMessages })
                });
                if (!response.ok) {
                    appendAgentMessage('agent', 'Kechirasiz, javob olishda xatolik yuz berdi.');
                    return;
                }
                const data = await response.json();
                const reply = data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : '';
                // Prefix assistant replies with the assistant name if not already present
                let finalReply = reply || 'Kechirasiz, men javob topa olmadim.';
                if (!finalReply.toLowerCase().startsWith('kago agent')) {
                    finalReply = 'Kago agent: ' + finalReply;
                }
                appendAgentMessage('agent', finalReply);
                agentConversation.push({ role: 'assistant', content: finalReply });
            } catch (err) {
                console.error(err);
                appendAgentMessage('agent', 'Kechirasiz, javob olishda xatolik yuz berdi.');
            }
        }

        // Event listeners for chat
        document.addEventListener('DOMContentLoaded', function() {
            if (agentNavBtn) {
                agentNavBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (agentModal) {
                        agentModal.style.display = 'block';
                        // ensure messages area starts at bottom of last conversation
                        if (agentMessagesEl) agentMessagesEl.scrollTop = agentMessagesEl.scrollHeight;
                        if (agentInput) agentInput.focus();
                    }
                });
            }
            if (closeAgentModal) {
                closeAgentModal.addEventListener('click', function() {
                    if (agentModal) agentModal.style.display = 'none';
                });
            }
            if (agentSendBtn) {
                agentSendBtn.addEventListener('click', function() {
                    handleAgentSend();
                });
            }
            if (agentInput) {
                agentInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleAgentSend();
                    }
                });
            }
        });
    </script>
</body>
</html>


